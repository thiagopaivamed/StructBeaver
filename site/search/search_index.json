{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"arvores/","title":"Introdu\u00e7\u00e3o \u00e0 arvores","text":"<p>Em mais um dia corrido, Gisele est\u00e1 planejando como organizar suas atividades. Para ir \u00e0 academia, que fica a certa dist\u00e2ncia de sua casa, ela precisa primeiro buscar seu carro na oficina mec\u00e2nica.</p> <p>Como alternativa \u00e0 academia, Gisele considerou se exercitar ao ar livre. No entanto, para isso, ela precisa comprar um t\u00eanis novo. Para fazer essa compra, o primeiro passo \u00e9 decidir qual meio de transporte utilizar. Em seguida, precisa verificar se o seu cart\u00e3o possui saldo suficiente. Caso contr\u00e1rio, ser\u00e1 necess\u00e1rio pagar a fatura antes de prosseguir.</p> <p>Sabe o que o planejamento da Gisele tem a ver com \u00e1rvores bin\u00e1rias? Tudo! Cada tarefa que ela precisa realizar pode ser vista como um n\u00f3 em uma \u00e1rvore. Para acessar novas atividades, ela precisa antes concluir as anteriores \u2014 exatamente como ao percorrer uma \u00e1rvore, em que \u00e9 necess\u00e1rio passar por n\u00f3s intermedi\u00e1rios para chegar aos pr\u00f3ximos.</p> <p>Ela tem dois caminhos poss\u00edveis: ir \u00e0 academia ou se exercitar ao ar livre \u2014 como em uma \u00e1rvore bin\u00e1ria, onde cada n\u00f3 pode levar a duas novas decis\u00f5es. \u00c0 medida que Gisele avan\u00e7a, novas tarefas s\u00e3o adicionadas como novos ramos em sua \u00e1rvore de planejamento, formando uma estrutura l\u00f3gica e encadeada que organiza seu dia.</p> <p>Vamos adentrar o fascinante mundo das \u00e1rvores bin\u00e1rias.</p> <p>8.1 \u00c1rvores bin\u00e1rias</p> <p>8.2 \u00c1rvores de pesquisa bin\u00e1ria</p> <p>8.3 \u00c1rvores AVL</p>"},{"location":"arvores/arvores-avl/","title":"\u00c1rvores de Pesquisa Bin\u00e1ria Balanceada (AVL)","text":""},{"location":"arvores/arvores-binarias/","title":"\u00c1rvores bin\u00e1rias","text":"<p>\u00c1rvores bin\u00e1rias s\u00e3o estruturas de dados n\u00e3o lineares que organizam elementos em uma hierarquia de n\u00f3s, com rela\u00e7\u00f5es entre pais e filhos. Diferente das listas encadeadas, que seguem uma sequ\u00eancia linear, as \u00e1rvores bin\u00e1rias se ramificam: cada n\u00f3 cont\u00e9m um valor e at\u00e9 duas refer\u00eancias \u2014 uma para o filho \u00e0 esquerda e outra para o filho \u00e0 direita. Essa estrutura permite representar decis\u00f5es, buscas e rela\u00e7\u00f5es de forma eficiente e organizada, sendo fundamental em diversos algoritmos e aplica\u00e7\u00f5es.</p> <pre><code>public class NoArvore (int valor)\n{\n    public int? Valor = valor;\n    public NoArvore? NoEsquerdo;\n    public NoArvore? NoDireito;\n}\n</code></pre> <p></p> <p>Cada n\u00f3 em uma \u00e1rvore bin\u00e1ria possui at\u00e9 duas refer\u00eancias: uma para o filho esquerdo e outra para o filho direito. O n\u00f3 no topo da estrutura, que n\u00e3o \u00e9 filho de nenhum outro, \u00e9 chamado de n\u00f3 raiz (root). Os n\u00f3s conectados \u00e0 esquerda e \u00e0 direita de qualquer n\u00f3 formam o que chamamos de sub\u00e1rvores.</p> <p>A altura de um n\u00f3 \u00e9 a maior dist\u00e2ncia (em n\u00famero de arestas) at\u00e9 uma folha em sua sub\u00e1rvore. Ou seja, qualquer n\u00f3 pode ter uma altura, n\u00e3o apenas a raiz. A altura da \u00e1rvore, por sua vez, \u00e9 definida como a altura da raiz.</p> <p>J\u00e1 a profundidade de um n\u00f3 \u00e9 a dist\u00e2ncia da raiz at\u00e9 esse n\u00f3, e varia conforme a posi\u00e7\u00e3o do n\u00f3 na \u00e1rvore. Esses dois conceitos \u2014 altura e profundidade \u2014 s\u00e3o fundamentais para entender a estrutura e o desempenho de algoritmos que utilizam \u00e1rvores.</p> <p></p>"},{"location":"arvores/arvores-binarias/#operacoes","title":"Opera\u00e7\u00f5es","text":"<p>Para a realiza\u00e7\u00e3o de opera\u00e7\u00f5es, vamos come\u00e7ar criando a nossa \u00e1rvore bin\u00e1ria.</p> <pre><code>public class ArvoreBinaria (NoArvore? raiz)\n{\n    public NoArvore? Raiz = raiz;\n}\n</code></pre>"},{"location":"arvores/arvores-binarias/#insercao-de-nos","title":"Inser\u00e7\u00e3o de n\u00f3s","text":"<p>Na inser\u00e7\u00e3o de n\u00f3s em uma \u00e1rvore bin\u00e1ria, o primeiro passo \u00e9 verificar se a \u00e1rvore est\u00e1 vazia. Se estiver, o novo n\u00f3 se torna a raiz. Caso contr\u00e1rio, a inser\u00e7\u00e3o segue uma estrat\u00e9gia de preenchimento \u2014 normalmente adicionando o novo n\u00f3 na primeira posi\u00e7\u00e3o dispon\u00edvel, da esquerda para a direita, em ordem de n\u00edvel. Como se trata de uma \u00e1rvore bin\u00e1ria n\u00e3o ordenada, n\u00e3o \u00e9 necess\u00e1rio comparar valores nem se preocupar com balanceamento ou ordena\u00e7\u00e3o dos n\u00f3s. O foco \u00e9 manter a estrutura bin\u00e1ria, em que cada n\u00f3 pode ter no m\u00e1ximo dois filhos.</p>"},{"location":"arvores/arvores-binarias/#complexidade","title":"Complexidade","text":"<p>Quando a inser\u00e7\u00e3o ocorre na raiz ou em um dos filhos imediatos (esquerdo ou direito) e essas posi\u00e7\u00f5es est\u00e3o dispon\u00edveis, a complexidade \u00e9 <code>O(1)</code>, pois n\u00e3o h\u00e1 necessidade de percorrer a \u00e1rvore. No entanto, nos demais casos, \u00e9 necess\u00e1rio percorrer os n\u00f3s at\u00e9 encontrar uma posi\u00e7\u00e3o livre, o que resulta em uma complexidade de <code>O(n)</code> no pior cen\u00e1rio \u2014 especialmente em \u00e1rvores muito desbalanceadas, como aquelas em que todos os n\u00f3s est\u00e3o alinhados \u00e0 direita, formando uma estrutura semelhante a uma lista ligada.</p> Caso Complexidade Melhor caso O(1) Caso m\u00e9dio O(n) Pior caso O(n)"},{"location":"arvores/arvores-binarias/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<pre><code>public NoArvore Inserir(int valor)\n{\n    NoArvore novoNo = new NoArvore(valor);\n\n    if (Raiz is null)\n    {\n        Raiz = novoNo;\n        return Raiz;\n    }\n\n    return InserirRecursivamente(Raiz, novoNo);\n}\n\nprivate NoArvore InserirRecursivamente(NoArvore atual, NoArvore novoNo)\n{\n    if (novoNo.Valor &lt; atual.Valor)\n    {\n        if (atual.NoEsquerdo is null)\n        {\n            atual.NoEsquerdo = novoNo;\n            return novoNo;\n        }\n\n        return InserirRecursivamente(atual.NoEsquerdo, novoNo);\n    }\n\n    else\n    {\n        if (atual.NoDireito is null)\n        {\n            atual.NoDireito = novoNo;\n            return novoNo;\n        }\n\n        return InserirRecursivamente(atual.NoDireito, novoNo);\n\n    }\n}\n</code></pre>"},{"location":"arvores/arvores-binarias/#pesquisa-de-nos-em-profundidade-dfs-depth-first-search","title":"Pesquisa de n\u00f3s em profundidade (DFS - Depth-First Search)","text":"<p>Uma forma comum de buscar um n\u00f3 em uma \u00e1rvore \u00e9 usando a Pesquisa em Profundidade (DFS \u2013 Depth-First Search). Nessa abordagem, come\u00e7amos pela raiz e exploramos o m\u00e1ximo poss\u00edvel cada ramo da \u00e1rvore antes de voltar e tentar outros caminhos.</p> <p>A DFS pode ser implementada de forma recursiva ou iterativa (usando uma pilha). A l\u00f3gica b\u00e1sica da busca \u00e9:</p> <ol> <li> <p>In\u00edcio da busca: Come\u00e7amos pela raiz da \u00e1rvore.</p> </li> <li> <p>Caso base: Se o n\u00f3 atual for null, significa que o valor n\u00e3o est\u00e1 na \u00e1rvore.</p> </li> <li> <p>Valor encontrado: Se o valor do n\u00f3 atual for o procurado, retornamos esse n\u00f3.</p> </li> <li> <p>Explora\u00e7\u00e3o: Se n\u00e3o for o valor, continuamos a busca nas sub\u00e1rvores \u2013 primeiro \u00e0 esquerda, depois \u00e0 direita.</p> </li> </ol> <p>Esse processo se repete at\u00e9 encontrar o valor ou percorrer todos os n\u00f3s da \u00e1rvore.</p> <p>Embora eficiente em \u00e1rvores balanceadas, a DFS pode ser menos eficiente em \u00e1rvores desbalanceadas, j\u00e1 que a profundidade aumenta e o tempo de busca pode crescer.</p>"},{"location":"arvores/arvores-binarias/#ordens-de-visita-na-dfs","title":"Ordens de visita na DFS","text":"<p>A DFS pode ser feita em tr\u00eas ordens diferentes, dependendo da posi\u00e7\u00e3o da raiz em rela\u00e7\u00e3o aos filhos:</p> <ol> <li> <p>Pr\u00e9-Ordem (PreOrder): Visita primeiro a raiz, depois o filho esquerdo e o filho direito.</p> </li> <li> <p>Em Ordem (InOrder): Visita primeiro o filho esquerdo, depois a raiz e, por fim, o filho direito.</p> </li> <li> <p>P\u00f3s-Ordem (PostOrder): Visita primeiro os filhos (esquerdo e direito) e s\u00f3 depois a raiz.</p> </li> </ol>"},{"location":"arvores/arvores-binarias/#complexidade_1","title":"Complexidade","text":"<p>Quando o n\u00f3 procurado \u00e9 a raiz da \u00e1rvore, a pesquisa ocorre em tempo constante, com complexidade <code>O(1)</code>, j\u00e1 que encontramos o n\u00f3 imediatamente. No entanto, se o n\u00f3 n\u00e3o for a raiz, ser\u00e1 necess\u00e1rio explorar outros ramos da \u00e1rvore. O algoritmo pode precisar visitar todos os n\u00f3s ou seguir o caminho mais profundo poss\u00edvel, explorando as sub\u00e1rvores at\u00e9 encontrar o n\u00f3 ou at\u00e9 chegar ao final da \u00e1rvore.</p> <p>Portanto, em casos em que o n\u00f3 procurado n\u00e3o \u00e9 a raiz, a complexidade de tempo ser\u00e1 <code>O(n)</code>, onde n \u00e9 o n\u00famero total de n\u00f3s na \u00e1rvore. Isso ocorre porque, no pior cen\u00e1rio, todos os n\u00f3s precisam ser visitados at\u00e9 encontrar o n\u00f3 desejado ou determinar que ele n\u00e3o est\u00e1 presente.</p> Caso Complexidade Melhor caso O(1) Caso m\u00e9dio O(n) Pior caso O(n)"},{"location":"arvores/arvores-binarias/#implementacao_1","title":"Implementa\u00e7\u00e3o","text":"DFS Pr\u00e9-OrdemDFS Em OrdemDFS P\u00f3s-Ordem <pre><code>public NoArvore? PesquisarComDfsPreOrdem(int valor)\n{\n    if (Raiz is null)\n        return null;\n\n    Stack&lt;NoArvore&gt; pilha = new();\n    pilha.Push(Raiz);\n\n    while (pilha.Count &gt; 0)\n    {\n        NoArvore noAtual = pilha.Pop();\n\n        if (noAtual.Valor == valor)\n            return noAtual;\n\n        if (noAtual.NoDireito is not null)\n            pilha.Push(noAtual.NoDireito);\n\n        if (noAtual.NoEsquerdo is not null)\n            pilha.Push(noAtual.NoEsquerdo);\n    }\n\n    return null;\n}        \n</code></pre> <pre><code>public NoArvore? PesquisarDfsEmOrdem(int valor)\n=&gt; PesquisarDfsEmOrdemRecursivo(Raiz, valor);\n\nprivate NoArvore? PesquisarDfsEmOrdemRecursivo(NoArvore? noAtual, int valor)\n{\n    if (noAtual is null)\n        return null;\n\n    // Busca na sub\u00e1rvore esquerda\n    NoArvore? noEsquerdo = PesquisarDfsEmOrdemRecursivo(noAtual.NoEsquerdo, valor);\n    if (noEsquerdo is not null)\n        return noEsquerdo;\n\n    // Verifica o n\u00f3 atual\n    if (noAtual.Valor == valor)\n        return noAtual;\n\n    // Busca na sub\u00e1rvore direita\n    return PesquisarDfsEmOrdemRecursivo(noAtual.NoDireito, valor);\n}\n</code></pre> <pre><code>public NoArvore? PesquisarDfsPosOrdem(int valor)\n=&gt; PesquisarDfsPosOrdemRecursivo(Raiz, valor);\n\nprivate NoArvore? PesquisarDfsPosOrdemRecursivo(NoArvore? noAtual, int valor)\n{\n    if (noAtual is null)\n        return null;\n\n    // Busca na sub\u00e1rvore esquerda\n    NoArvore? noEsquerdo = PesquisarDfsPosOrdemRecursivo(noAtual.NoEsquerdo, valor);\n    if (noEsquerdo is not null)\n        return noEsquerdo;\n\n    // Busca na sub\u00e1rvore direita\n    NoArvore? noDireito = PesquisarDfsPosOrdemRecursivo(noAtual.NoDireito, valor);\n    if (noDireito is not null)\n        return noDireito;\n\n    // Verifica o n\u00f3 atual\n    if (noAtual.Valor == valor)\n        return noAtual;\n\n    return null;\n}\n</code></pre> DFS Pr\u00e9-OrdemDFS Em OrdemDFS P\u00f3s-Ordem"},{"location":"arvores/arvores-binarias/#pesquisa-de-nos-em-largura-breadth-first-search","title":"Pesquisa de n\u00f3s em largura (Breadth-First Search)","text":"<p>Outra forma de pesquisar por n\u00f3s \u00e9 usando a pesquisa em largura. Ela consiste em visitar os n\u00f3s da \u00e1rvore n\u00edvel por n\u00edvel. A pesquisa come\u00e7a pela raiz da \u00e1rvore, visita todos os vizinhos (filhos diretos) antes de descer para o n\u00edvel abaixo e para manter a ordem de visita\u00e7\u00e3o, usamos uma fila ou recurs\u00e3o.</p>"},{"location":"arvores/arvores-binarias/#complexidade_2","title":"Complexidade","text":"<p>Se o n\u00f3 procurado for a raiz, ent\u00e3o a complexidade \u00e9 <code>O(1)</code>. Caso contr\u00e1rio, ser\u00e1 necess\u00e1rio visitar os n\u00f3s at\u00e9 achar o n\u00f3 procurado. Nesse caso, a complexidade \u00e9 <code>O(n)</code>.</p> Caso Complexidade Melhor caso O(1) Caso m\u00e9dio O(n) Pior caso O(n)"},{"location":"arvores/arvores-binarias/#implementacao_2","title":"Implementa\u00e7\u00e3o","text":"<pre><code>public NoArvore? PesquisarComBfs(int valor)\n{\n    if (Raiz is null) \n        return null;\n\n    Queue&lt;NoArvore&gt; nosVisitados = new();\n    nosVisitados.Enqueue(Raiz);\n\n    while (nosVisitados.Count &gt; 0)\n    {\n        NoArvore noAtual = nosVisitados.Dequeue();\n\n        if (noAtual.Valor == valor)\n            return noAtual;\n\n        if (noAtual.NoEsquerdo is not null)\n            nosVisitados.Enqueue(noAtual.NoEsquerdo);\n\n        if (noAtual.NoDireito is not null)\n            nosVisitados.Enqueue(noAtual.NoDireito);\n    }\n\n    return null;\n}\n</code></pre>"},{"location":"arvores/arvores-binarias/#remocao-de-nos","title":"Remo\u00e7\u00e3o de n\u00f3s","text":"<p>A remo\u00e7\u00e3o de um n\u00f3 em uma \u00e1rvore bin\u00e1ria de busca envolve 3 casos principais:</p> <ol> <li> <p>N\u00f3 sem filhos (n\u00f3 folha) O n\u00f3 \u00e9 removido e simplesmente a refer\u00eancia para ele se torna <code>null</code>.</p> </li> <li> <p>N\u00f3 com um filho (esquerdo ou direito) O n\u00f3 \u00e9 removido e o filho (caso exista) ocupa o lugar dele, ou seja, a refer\u00eancia ao n\u00f3 \u00e9 substitu\u00edda pela refer\u00eancia ao filho.</p> </li> <li> <p>N\u00f3 com dois filhos O n\u00f3 \u00e9 removido, mas como ele tem dois filhos, precisamos encontrar uma forma de mant\u00ea-lo na estrutura da \u00e1rvore. O m\u00e9todo utilizado aqui \u00e9 substituir o n\u00f3 pelo seu sucessor, ou seja, o n\u00f3 de menor valor na sub\u00e1rvore \u00e0 direita do n\u00f3 a ser removido.</p> </li> </ol>"},{"location":"arvores/arvores-binarias/#complexidade_3","title":"Complexidade","text":"<p>Em uma \u00e1rvore balanceada, o tempo necess\u00e1rio para percorrer at\u00e9 o n\u00f3 desejado \u00e9 proporcional \u00e0 altura da \u00e1rvore. Portanto, a opera\u00e7\u00e3o de remo\u00e7\u00e3o, que envolve procurar o n\u00f3 e, em alguns casos, encontrar o sucessor e remov\u00ea-lo, leva <code>O(log n)</code> tempo.</p> <p>No pior caso, a \u00e1rvore pode se tornar uma lista encadeada (se os elementos forem inseridos em ordem crescente ou decrescente, por exemplo). Nesse caso, a opera\u00e7\u00e3o de remo\u00e7\u00e3o teria uma complexidade de <code>O(n)</code>.</p> Caso Complexidade Melhor caso O(log n) Caso m\u00e9dio O(log n) Pior caso O(n)"},{"location":"arvores/arvores-binarias/#implementacao_3","title":"Implementa\u00e7\u00e3o","text":"<pre><code>public void Remover(int valor)\n    =&gt; Raiz = RemoverRecursivo(Raiz, valor);\n\nprivate NoArvore? RemoverRecursivo(NoArvore? noAtual, int valor)\n{\n    if (noAtual is null)\n        return null;\n\n    if (valor &lt; noAtual.Valor)\n        noAtual.NoEsquerdo = RemoverRecursivo(noAtual.NoEsquerdo, valor);\n\n    else if (valor &gt; noAtual.Valor)\n        noAtual.NoDireito = RemoverRecursivo(noAtual.NoDireito, valor);\n\n    else\n    {\n        // Caso 1: Sem filhos\n        if (noAtual.NoEsquerdo is null &amp;&amp; noAtual.NoDireito is null)\n            return null;\n\n        // Caso 2: Um filho\n        if (noAtual.NoEsquerdo is null)\n            return noAtual.NoDireito;\n\n        if (noAtual.NoDireito is null)\n            return noAtual.NoEsquerdo;\n\n        // Caso 3: Dois filhos\n        NoArvore noSucessor = EncontrarMinimo(noAtual.NoDireito);\n        noAtual.Valor = noSucessor.Valor;\n        noAtual.NoDireito = RemoverRecursivo(noAtual.NoDireito, noSucessor.Valor.Value);\n    }\n\n    return noAtual;\n}\n\nprivate NoArvore EncontrarMinimo(NoArvore? noAtual)\n{\n    while (noAtual?.NoEsquerdo is not null)\n        noAtual = noAtual.NoEsquerdo;\n\n    return noAtual;\n}\n</code></pre> \u00c1rvore inicialRemo\u00e7\u00e3o - Caso 01 - N\u00f3 sem filhosRemo\u00e7\u00e3o - Caso 02 - N\u00f3 com 1 filhoRemo\u00e7\u00e3o - Caso 03 - N\u00f3 com filhos\u00c1rvore resultante das 3 remo\u00e7\u00f5es"},{"location":"arvores/arvores-pesquisas-binarias/","title":"\u00c1rvore de pesquisa bin\u00e1ria (BST - Binary Search Tree)","text":"<p>A \u00e1rvore de pesquisa bin\u00e1ria \u00e9 um tipo espec\u00edfico de \u00e1rvore bin\u00e1ria que organiza seus elementos de forma ordenada, permitindo opera\u00e7\u00f5es eficientes de busca, inser\u00e7\u00e3o e remo\u00e7\u00e3o.</p> <p>Sua estrutura \u00e9 hier\u00e1rquica e recursiva, e segue uma regra fundamental de ordena\u00e7\u00e3o:</p> <ul> <li> <p>Para cada n\u00f3, todos os elementos da sub\u00e1rvore \u00e0 esquerda devem ter valores menores que o valor do n\u00f3.</p> </li> <li> <p>Todos os elementos da sub\u00e1rvore \u00e0 direita devem ter valores maiores.</p> </li> </ul> <p>Essa propriedade deve ser mantida recursivamente em toda a \u00e1rvore.</p> <p>Al\u00e9m disso:</p> <ul> <li> <p>Cada valor armazenado \u00e9 \u00fanico (a BST tradicional n\u00e3o permite duplica\u00e7\u00f5es).</p> </li> <li> <p>A estrutura inicial de uma \u00e1rvore de pesquisa bin\u00e1ria \u00e9 igual \u00e0 de uma \u00e1rvore bin\u00e1ria comum \u2014 o que muda s\u00e3o as regras para inser\u00e7\u00e3o, busca e remo\u00e7\u00e3o de n\u00f3s, que devem sempre respeitar a ordena\u00e7\u00e3o bin\u00e1ria.</p> </li> </ul> <pre><code>public class NoArvore (int valor)\n{\n    public int? Valor = valor;\n    public NoArvore? NoEsquerdo;\n    public NoArvore? NoDireito;\n}\n</code></pre> <pre><code>public class ArvorePesquisaBinaria (NoArvore noArvore)\n{\n    public NoArvore Raiz = noArvore;   \n}\n</code></pre> <p></p>"},{"location":"arvores/arvores-pesquisas-binarias/#operacoes","title":"Opera\u00e7\u00f5es","text":"<p>Vamos usar a \u00e1rvore de pesquisa bin\u00e1ria criada recentemente para realizar as opera\u00e7\u00f5es.</p>"},{"location":"arvores/arvores-pesquisas-binarias/#insercao-de-nos","title":"Inser\u00e7\u00e3o de n\u00f3s","text":"<p>A inser\u00e7\u00e3o de um novo n\u00f3 em uma \u00e1rvore de pesquisa bin\u00e1ria segue uma l\u00f3gica baseada em compara\u00e7\u00f5es:</p> <ol> <li> <p>Compara\u00e7\u00e3o com o n\u00f3 atual: come\u00e7ando pela raiz, compara-se o valor a ser inserido com o valor do n\u00f3 atual:</p> </li> <li> <p>Se o valor for menor, a busca continua na sub\u00e1rvore esquerda.</p> </li> <li> <p>Se for maior, segue-se para a sub\u00e1rvore direita.</p> </li> <li> <p>Esse processo se repete recursivamente at\u00e9 encontrar uma posi\u00e7\u00e3o vazia (um ponteiro <code>null</code>).</p> </li> <li> <p>Evita duplica\u00e7\u00f5es: caso o valor a ser inserido j\u00e1 exista na \u00e1rvore, ele n\u00e3o ser\u00e1 inserido, preservando a propriedade de que todos os valores na \u00e1rvore s\u00e3o \u00fanicos.</p> </li> </ol>"},{"location":"arvores/arvores-pesquisas-binarias/#complexidade","title":"Complexidade","text":"<p>Para inserir um novo n\u00f3 em uma \u00e1rvore de pesquisa bin\u00e1ria, \u00e9 necess\u00e1rio percorrer a \u00e1rvore desde a raiz at\u00e9 encontrar a posi\u00e7\u00e3o correta. Esse caminho depende da altura da \u00e1rvore.</p> <p>Quando a \u00e1rvore est\u00e1 relativamente balanceada, o n\u00famero de compara\u00e7\u00f5es necess\u00e1rias para encontrar a posi\u00e7\u00e3o de inser\u00e7\u00e3o cresce de forma logar\u00edtmica em rela\u00e7\u00e3o ao n\u00famero de n\u00f3s. Isso significa que, em m\u00e9dia, a inser\u00e7\u00e3o ocorre em tempo <code>O(log n)</code>.</p> <p>Se a \u00e1rvore estiver desbalanceada, como quando os elementos s\u00e3o inseridos em ordem crescente ou decrescente, ela se degenera em uma lista encadeada. Nessa situa\u00e7\u00e3o, \u00e9 preciso percorrer todos os n\u00f3s para inserir o novo valor, resultando em uma complexidade <code>O(n)</code>.</p> Caso Complexidade Melhor caso O(1) Caso m\u00e9dio O(log n) Pior caso O(n)"},{"location":"arvores/arvores-pesquisas-binarias/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<pre><code>public NoArvore Inserir(int valor)\n    =&gt; InserirRecursivo(Raiz, valor);\n\nprivate NoArvore InserirRecursivo(NoArvore noAtual, int valor)\n{\n    if (valor &lt; noAtual.Valor)\n    {\n        if (noAtual.NoEsquerdo is null)\n        {\n            noAtual.NoEsquerdo = new(valor);\n            return noAtual.NoEsquerdo;\n        }\n        else\n            return InserirRecursivo(noAtual.NoEsquerdo, valor);\n\n    }\n    else if (valor &gt; noAtual.Valor)\n    {\n        if (noAtual.NoDireito == null)\n        {\n            noAtual.NoDireito = new NoArvore(valor);\n            return noAtual.NoDireito;\n        }\n        else\n            return InserirRecursivo(noAtual.NoDireito, valor);\n\n    }\n\n    // Se valor j\u00e1 existir, n\u00e3o insere e retorna o pr\u00f3prio n\u00f3\n    return noAtual;\n}\n</code></pre>"},{"location":"arvores/arvores-pesquisas-binarias/#pesquisa-binaria-na-arvore-de-pesquisa-binaria","title":"Pesquisa bin\u00e1ria na \u00c1rvore de Pesquisa Bin\u00e1ria","text":"<p>Embora seja poss\u00edvel realizar pesquisas em largura (BFS) e em profundidade (DFS) em uma \u00e1rvore bin\u00e1ria de pesquisa, esse tipo de estrutura possui um m\u00e9todo pr\u00f3prio e mais eficiente para localizar elementos: a pesquisa bin\u00e1ria. Essa pesquisa aproveita a ordena\u00e7\u00e3o dos n\u00f3s para descartar metade da \u00e1rvore a cada compara\u00e7\u00e3o, tornando o processo muito mais r\u00e1pido. Esse comportamento segue o paradigma de divis\u00e3o e conquista, onde o problema \u00e9 reduzido progressivamente at\u00e9 que a solu\u00e7\u00e3o seja encontrada ou determinada como inexistente.</p>"},{"location":"arvores/arvores-pesquisas-binarias/#complexidade_1","title":"Complexidade","text":"<p>Se o n\u00f3 pesquisado for a raiz da \u00e1rvore, a pesquisa \u00e9 imediata, resultando em uma complexidade de <code>O(1)</code>. No caso m\u00e9dio, \u00e9 necess\u00e1rio percorrer parte da \u00e1rvore. Como a pesquisa bin\u00e1ria segue o paradigma de divis\u00e3o e conquista, a cada passo descartamos uma sub\u00e1rvore inteira, o que leva a uma complexidade de <code>O(log\u202fn)</code> em \u00e1rvores balanceadas. No entanto, no pior caso \u2014 quando a \u00e1rvore est\u00e1 completamente desbalanceada, assumindo a forma de uma lista encadeada \u2014 a pesquisa percorre todos os n\u00f3s, resultando em uma complexidade de <code>O(n)</code>.</p>"},{"location":"arvores/arvores-pesquisas-binarias/#implementacao_1","title":"Implementa\u00e7\u00e3o","text":"<pre><code>public NoArvore? Pesquisar(int valor)\n    =&gt; PesquisarRecursivo(Raiz, valor);\n\nprivate NoArvore? PesquisarRecursivo(NoArvore? noAtual, int valor)\n{\n    if (noAtual == null)\n        return null;\n\n    if (valor == noAtual.Valor)\n        return noAtual;\n\n    if (valor &lt; noAtual.Valor)\n        return PesquisarRecursivo(noAtual.NoEsquerdo, valor);\n\n    return PesquisarRecursivo(noAtual.NoDireito, valor);\n}\n</code></pre>"},{"location":"filas/","title":"Introdu\u00e7\u00e3o \u00e0 filas","text":"<p>Ap\u00f3s o lan\u00e7amento de um filme muito aguardado nos cinemas, Tha\u00eds, exausta ap\u00f3s um dia estressante de trabalho, decidiu assisti-lo. Como a sess\u00e3o estava lotada e os assentos n\u00e3o eram marcados, os lugares seriam ocupados por ordem de chegada.</p> <p>Tha\u00eds logo percebeu que, quanto mais cedo entrasse na sala, mais op\u00e7\u00f5es de lugares teria para escolher. Por isso, apressou-se para estar entre as primeiras da fila. Ao entrar, notou algo curioso: os assentos mais pr\u00f3ximos da tela e da sa\u00edda eram os mais f\u00e1ceis de acessar e permitiriam uma sa\u00edda mais r\u00e1pida ao fim da sess\u00e3o. J\u00e1 quem escolhesse se sentar mais ao fundo teria que atravessar toda a fileira \u2014 tanto para entrar quanto para sair da sala.</p> <p>Essa situa\u00e7\u00e3o reflete bem o funcionamento da estrutura de dados que estamos prestes a conhecer: a fila.</p> <p>Em uma fila, o primeiro elemento a entrar \u00e9 sempre o primeiro a sair. A inser\u00e7\u00e3o de novos dados acontece sempre no final da fila, enquanto a remo\u00e7\u00e3o ocorre no seu in\u00edcio.</p> <p>Vamos entender melhor como essa estrutura funciona e onde ela pode ser aplicada.</p> <p>6.1 Filas e suas opera\u00e7\u00f5es</p> <p>6.2 Implementa\u00e7\u00e3o padr\u00e3o de filas usando C#</p> <p>6.3 Exerc\u00edcios de filas</p>"},{"location":"filas/exercicios-filas/","title":"Exerc\u00edcios de filas","text":"<p>(1) Escreva uma fun\u00e7\u00e3o que transfere todos os elementos de uma fila para outra.</p> Copiando dados <pre><code>public class CopiaFila\n{\n    public Fila CopiarDados(Fila fila)\n    {\n        Fila filaCopia = new Fila();\n\n        while(!fila.IsEmpty())\n            filaCopia.Enqueue(fila.Dequeue());\n\n        return filaCopia;\n    }\n}\n</code></pre> <p>(2) Crie uma fun\u00e7\u00e3o que compare duas filas e verifique se s\u00e3o iguais (ordem e valores).</p> Compara\u00e7\u00e3o de filas <pre><code>public class VerificaFilas\n{\n    public bool VerificarFilasPorOrdemValores(Fila fila1, Fila fila2)\n    {\n        while(!fila1.IsEmpty() &amp;&amp; !fila2.IsEmpty())\n        {\n            int valorFila1 = fila1.Dequeue();\n            int valorFila2 = fila2.Dequeue();\n\n            if(valorFila1 != valorFila2)\n                return false;\n        }\n        return true;\n    }\n}\n</code></pre> <p>(3) Dada uma fila de n\u00fameros, crie uma fun\u00e7\u00e3o que retorne a m\u00e9dia dos valores.</p> M\u00e9dia de valores <pre><code>public class MediaValoresFila\n{\n    public double CalcularMedia(Fila fila)\n    {\n        int totalValores = 0;\n        double somaValores = 0;\n\n        while(!fila.IsEmpty())\n        {\n            double valor = fila.Dequeue();\n            totalValores = totalValores + 1;\n            somaValores = somaValores + valor;\n        }\n\n        return somaValores / totalValores;\n    }\n}\n</code></pre> <p>(4) Dada uma fila, crie uma fun\u00e7\u00e3o que rotacione os elementos n vezes (ex: [1,2,3] \u2192 [2,3,1]).</p> Rotacionando a fila <pre><code>public class RotacaoFila\n{\n    public Fila Rotacionar(Fila fila, int vezes)\n    {\n        while(vezes &gt; 0)\n        {\n            int valor = fila.Dequeue();\n            fila.Enqueue(valor);\n            vezes = vezes - 1;\n        }\n\n        return fila;\n    }\n}\n</code></pre> <p>(5) Dada uma fila, use o m\u00e9todo Merge Sort para ordenar a mesma.</p> Ordenando fila com Merge Sort <pre><code>public class OrdenacaoFila\n{\n    public Fila Ordenar(Fila fila)\n    {\n        int quantidadeElementos = fila.Size();\n        int[] elementosFila = new int[quantidadeElementos];\n\n        for (int i = 0; i &lt; quantidadeElementos; i++)\n            elementosFila[i] = fila.Dequeue();\n\n        int[] elementosOrdenados = Sort(elementosFila);\n\n        for (int i = 0; i &lt; quantidadeElementos; i++)\n            fila.Enqueue(elementosOrdenados[i]);\n\n        return fila;\n    }\n\n    private int[] Sort(int[] vetor)\n    {\n        int quantidadeElementos = vetor.Length;\n\n        if (quantidadeElementos &lt;= 1)\n            return vetor;\n\n        int meio = quantidadeElementos / 2;\n        int[] vetorEsquerdo = new int[meio];\n        int[] vetorDireito = new int[quantidadeElementos - meio];\n\n        int indiceVetorEsquerdo = 0;\n        int indiceVetorDireito = 0;\n\n        for (; indiceVetorEsquerdo &lt; quantidadeElementos; indiceVetorEsquerdo++)\n        {\n            if (indiceVetorEsquerdo &lt; meio)\n                vetorEsquerdo[indiceVetorEsquerdo] = vetor[indiceVetorEsquerdo];\n            else\n            {\n                vetorDireito[indiceVetorDireito] = vetor[indiceVetorEsquerdo];\n                indiceVetorDireito = indiceVetorDireito + 1;\n            }\n        }\n\n        vetorEsquerdo = Sort(vetorEsquerdo);\n        vetorDireito = Sort(vetorDireito);\n        Merge(vetor, vetorEsquerdo, vetorDireito);\n\n        return vetor;\n    }\n\n    private void Merge(int[] vetor, int[] vetorEsquerdo, int[] vetorDireito)\n    {\n        int quantidadeElementosVetorEsquerdo = vetorEsquerdo.Length;\n        int quantidadeElementosVetorDireito = vetorDireito.Length;\n        int indiceVetor = 0;\n        int indiceVetorEsquerdo = 0;\n        int indiceVetorDireito = 0;\n\n        while (indiceVetorEsquerdo &lt; quantidadeElementosVetorEsquerdo &amp;&amp; indiceVetorDireito &lt; quantidadeElementosVetorDireito)\n        {\n            if (vetorEsquerdo[indiceVetorEsquerdo] &lt; vetorDireito[indiceVetorDireito])\n            {\n                vetor[indiceVetor] = vetorEsquerdo[indiceVetorEsquerdo];\n                indiceVetor = indiceVetor + 1;\n                indiceVetorEsquerdo = indiceVetorEsquerdo + 1;\n            }\n            else\n            {\n                vetor[indiceVetor] = vetorDireito[indiceVetorDireito];\n                indiceVetor = indiceVetor + 1;\n                indiceVetorDireito = indiceVetorDireito + 1;\n            }\n        }\n\n        while (indiceVetorEsquerdo &lt; quantidadeElementosVetorEsquerdo)\n        {\n            vetor[indiceVetor] = vetorEsquerdo[indiceVetorEsquerdo];\n            indiceVetor = indiceVetor + 1;\n            indiceVetorEsquerdo = indiceVetorEsquerdo + 1;\n        }\n\n        while (indiceVetorDireito &lt; quantidadeElementosVetorDireito)\n        {\n            vetor[indiceVetor] = vetorDireito[indiceVetorDireito];\n            indiceVetor = indiceVetor + 1;\n            indiceVetorDireito = indiceVetorDireito + 1;\n        }\n    }\n}\n</code></pre>"},{"location":"filas/filas-c-sharp/","title":"Implementa\u00e7\u00e3o padr\u00e3o de filas usando C#","text":"<p>A linguagem C# j\u00e1 fornece uma estrutura de fila pronta por meio da classe <code>Queue&lt;T&gt;</code>, dispon\u00edvel em <code>System.Collections.Generic</code>. As principais opera\u00e7\u00f5es s\u00e3o: <code>Enqueue</code> para inserir elementos, <code>Dequeue</code> para remover o topo e <code>Peek</code> para visualizar o topo sem remov\u00ea-lo. Para verificar o tamanho da pilha ou saber se ela est\u00e1 vazia, utilizamos a propriedade <code>Count</code>.</p>"},{"location":"filas/filas-c-sharp/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<pre><code>public class FilaPadrao\n{\n    private Queue&lt;int&gt; Itens;\n\n    public FilaPadrao()\n        =&gt; Itens = new Queue&lt;int&gt;();\n\n    public void Enqueue(int item)\n        =&gt; Itens.Enqueue(item);\n\n    public int Dequeue()\n        =&gt; Itens.Dequeue();\n\n    public int Peek()\n        =&gt; Itens.Peek();\n\n    public bool IsEmpty() =&gt; Itens.Count == 0;\n\n    public int Size() =&gt; Itens.Count;\n}\n</code></pre> Opera\u00e7\u00f5es em uma fila"},{"location":"filas/filas-operacoes/","title":"Filas e suas opera\u00e7\u00f5es","text":"<p>Filas s\u00e3o estruturas de dados do tipo <code>FIFO (First In, First Out)</code>, em que o primeiro elemento inserido \u00e9 o primeiro a ser removido. Assim como em uma fila de atendimento, apenas o elemento na frente est\u00e1 dispon\u00edvel para acesso imediato. Suas opera\u00e7\u00f5es principais incluem: <code>Enqueue</code>, para adicionar um elemento ao final; <code>Dequeue</code>, para remover e retornar o primeiro elemento; <code>Peek</code> ou <code>Front</code>, para visualizar o primeiro elemento sem remov\u00ea-lo; <code>IsEmpty</code>, para verificar se a fila est\u00e1 vazia; e <code>Size</code>, que retorna a quantidade de elementos na fila.</p>"},{"location":"filas/filas-operacoes/#insercao-de-dados-enqueue","title":"Inser\u00e7\u00e3o de dados (Enqueue)","text":"<p>A inser\u00e7\u00e3o de elementos em uma fila ocorre sempre ao final da estrutura, de forma direta, sem a necessidade de percorr\u00ea-la. Por isso, essa opera\u00e7\u00e3o possui complexidade de tempo constante, ou seja, <code>O(1)</code>.</p> Caso Complexidade Melhor caso O(1) Caso m\u00e9dio O(1) Pior caso O(1)"},{"location":"filas/filas-operacoes/#remocao-de-dados-dequeue","title":"Remo\u00e7\u00e3o de dados (Dequeue)","text":"<p>A remo\u00e7\u00e3o de elementos em uma fila ocorre sempre no in\u00edcio da estrutura, de forma direta e sem a necessidade de percorrer os dados. Por isso, essa opera\u00e7\u00e3o tamb\u00e9m possui complexidade constante, ou seja, <code>O(1)</code>.</p> Caso Complexidade Melhor caso O(1) Caso m\u00e9dio O(1) Pior caso O(1)"},{"location":"filas/filas-operacoes/#pegando-dados-peek","title":"Pegando dados (Peek)","text":"<p>Qualquer tentativa de acesso a um elemento em uma fila sempre retornar\u00e1 o primeiro item, sem a necessidade de percorrer a estrutura. Por esse motivo, a opera\u00e7\u00e3o tamb\u00e9m apresenta complexidade constante, ou seja, <code>O(1)</code>.</p> Caso Complexidade Melhor caso O(1) Caso m\u00e9dio O(1) Pior caso O(1)"},{"location":"filas/filas-operacoes/#verificando-se-a-fila-esta-vazia-isempty","title":"Verificando se a fila est\u00e1 vazia (IsEmpty)","text":"<p>Nesse caso, o que ocorre \u00e9 apenas a verifica\u00e7\u00e3o da exist\u00eancia de um elemento na primeira posi\u00e7\u00e3o da fila, uma opera\u00e7\u00e3o simples e direta, que tamb\u00e9m possui complexidade constante, ou seja, <code>O(1)</code>.</p> Caso Complexidade Melhor caso O(1) Caso m\u00e9dio O(1) Pior caso O(1)"},{"location":"filas/filas-operacoes/#verificando-o-tamanho-da-fila-size","title":"Verificando o tamanho da fila (Size)","text":"<p>Ao manter um contador atualizado na estrutura da fila, \u00e9 poss\u00edvel obter seu tamanho diretamente, sem percorrer os elementos. Dessa forma, a complexidade da opera\u00e7\u00e3o permanece constante, ou seja, <code>O(1)</code>.</p> Caso Complexidade Melhor caso O(1) Caso m\u00e9dio O(1) Pior caso O(1) <p>Uso no dia-a-dia</p> <p>A estrutura de fila \u00e9 amplamente utilizada em cen\u00e1rios como o gerenciamento de tarefas, sistemas de atendimento, envio de mensagens em chats e outros contextos onde \u00e9 necess\u00e1rio processar elementos na ordem em que s\u00e3o recebidos.</p>"},{"location":"filas/filas-operacoes/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<pre><code>public class Fila\n{\n    private int[] Itens;\n    private int Inicio;\n    private int Fim;\n    private int Tamanho;\n    private const int Capacidade = 10;\n\n    public Fila()\n    {\n        Itens = new int[Capacidade];\n        Inicio = 0;\n        Fim = 0;\n        Tamanho = 0;\n    }\n\n    public void Enqueue(int item)\n    {\n        if (Tamanho == Capacidade)\n            throw new InvalidOperationException(\"Fila cheia.\");\n\n        Itens[Fim] = item;\n        Fim = Fim + 1;\n        Tamanho = Tamanho + 1;\n    }\n\n    public int Dequeue()\n    {\n        if (IsEmpty())\n            throw new InvalidOperationException(\"Fila vazia.\");\n\n        int item = Itens[Inicio];\n        Inicio = Inicio + 1;\n        Tamanho = Tamanho - 1;\n        return item;\n    }\n\n    public int Peek()\n    {\n        if (IsEmpty())\n            throw new InvalidOperationException(\"Fila vazia.\");\n\n        return Itens[Inicio];\n    }\n\n    public bool IsEmpty() =&gt; Tamanho == 0;\n\n    public int Size() =&gt; Tamanho;\n}\n</code></pre> Opera\u00e7\u00f5es em uma fila"},{"location":"listas/","title":"Introdu\u00e7\u00e3o \u00e0 listas","text":"<p>Ap\u00f3s atender diversos clientes em sua cl\u00ednica veterin\u00e1ria e enfrentar uma rotina exaustiva todos os dias, B\u00e1rbara decidiu tirar uma pausa. Para a semana seguinte, escolheu descansar em um chal\u00e9 nas montanhas \u2014 um ref\u00fagio tranquilo onde pudesse relaxar e refletir sobre novas ideias para aprimorar o atendimento em seu neg\u00f3cio.</p> <p>Depois de horas de pesquisa, B\u00e1rbara descobriu que precisaria pegar um avi\u00e3o para chegar ao seu destino. A jornada come\u00e7aria no aeroporto Z, com uma conex\u00e3o no aeroporto X, seguida por outra no aeroporto C, at\u00e9 finalmente aterrissar no aeroporto V. Curiosamente, ap\u00f3s completar o trajeto, o avi\u00e3o retornaria ao ponto de partida: o aeroporto Z.</p> <p>Para chegar ao aeroporto V, algumas conex\u00f5es seriam necess\u00e1rias \u2014 exatamente como em uma lista encadeada. Imagine os aeroportos Z, X, C e V como n\u00f3s ligados entre si: ao partir de Z, \u00e9 preciso passar por X e C at\u00e9 chegar a V. Numa lista encadeada simples, o trajeto \u00e9 unidirecional \u2014 seguimos sempre para o pr\u00f3ximo. No entanto, se for poss\u00edvel retornar de V para C, de C para X e de X para Z, estamos diante de uma lista duplamente encadeada, onde o caminho pode ser percorrido em ambas as dire\u00e7\u00f5es. E se o avi\u00e3o continuar repetindo o ciclo Z \u2192 X \u2192 C \u2192 V \u2192 Z, esse comportamento remete a uma lista circular, em que o \u00faltimo elemento se conecta de volta ao primeiro, formando um percurso cont\u00ednuo.</p> <p>Vamos explorar mais a fundo como essas listas funcionam.</p> <p>7.1 Listas encadeadas e suas opera\u00e7\u00f5es</p> <p>7.2 Listas encadeadas padr\u00e3o em C#</p> <p>7.3 Listas duplamente encadeadas e suas opera\u00e7\u00f5es</p> <p>7.4 Listas duplamente encadeadas padr\u00e3o em C#</p> <p>7.5 Listas circulares duplamente encadeadas e suas opera\u00e7\u00f5es</p> <p>7.6 Exerc\u00edcios de listas</p>"},{"location":"listas/exercicios-listas/","title":"Exerc\u00edcios","text":"<p>(1) Dada uma lista encadeada, crie uma fun\u00e7\u00e3o para inverter os seus elementos.</p> Invertendo elementos <pre><code>public class InversaoElementosListaEncadeada\n{\n    public ListaEncadeada Inverter(ListaEncadeada listaParaInversao)\n    {\n        ListaEncadeada listaInvertida = new ListaEncadeada();\n\n        while (!listaParaInversao.IsEmpty())\n        {\n            No noRemovido = listaParaInversao.RemoverNoInicio();\n\n            if (noRemovido is not null)\n                listaInvertida.AdicionarNoInicio(noRemovido.Valor);\n        }\n\n        return listaInvertida;\n    }\n}\n</code></pre> <p>(2) Dada uma lista encadeada, crie uma fun\u00e7\u00e3o recursiva para fazer a pesquisa de um valor.</p> Pesquisa valores em lista de forma recursiva <pre><code>public class PesquisaRecursivaListaEncadeada\n{\n    public bool Pesquisar(ListaEncadeada listaEncadeada, int valorProcurado)\n    {\n        No noAtual = listaEncadeada.PegarPrimeiroNo();\n\n        return PesquisarRecursivo(noAtual, valorProcurado);\n    }\n\n    private bool PesquisarRecursivo(No noAtual, int valorProcurado)\n    {\n        if (noAtual is null)\n            return false;\n\n        if (noAtual.Valor == valorProcurado)\n            return true;\n\n        return PesquisarRecursivo(noAtual.Proximo, valorProcurado);\n    }\n}\n</code></pre> <p>(3) Dadas duas listas encadeadas, implemente uma fun\u00e7\u00e3o recursiva que as mescle em uma \u00fanica lista encadeada.</p> Juntando listas recursivamente <pre><code>public class JuncaoListasEncadeadas\n{\n    public ListaEncadeada FazerMerge(ListaEncadeada lista1, ListaEncadeada lista2)\n    {\n        ListaEncadeada listasCombinadas = new ListaEncadeada();\n\n        No? no1 = lista1.PegarPrimeiroNo();\n        No? no2 = lista2.PegarPrimeiroNo();\n\n        return MergeRecursivo(no1, no2, listasCombinadas);           \n    }\n\n    private ListaEncadeada MergeRecursivo(No? no1, No? no2, ListaEncadeada listasCombinadas)\n    {\n        if(no1 is null &amp;&amp; no2 is null)            \n            return listasCombinadas;\n\n        if (no1 is not null)\n            listasCombinadas.AdicionarNoFim(no1.Valor);\n\n        if (no2 is not null)\n            listasCombinadas.AdicionarNoFim(no2.Valor);\n\n        return MergeRecursivo(no1?.Proximo, no2?.Proximo, listasCombinadas);            \n    }\n}\n</code></pre> <p>(4) Dado uma lista encadeada, utilize a ordena\u00e7\u00e3o por inser\u00e7\u00e3o (insertion sort) para ordenar seus elementos.</p> Insertion Sort para listas <pre><code>public class InsertionSortListaEncadeada\n{\n    public ListaEncadeada Ordenar(ListaEncadeada listaParaOrdenar)\n    {\n        ListaEncadeada listaOrdenada = new ListaEncadeada();\n        No? noAtual = listaParaOrdenar.PrimeiroNo;\n\n        while (noAtual != null)\n        {\n            No novoNo = new No(noAtual.Valor);\n\n            if (listaOrdenada.PrimeiroNo is null || novoNo.Valor &lt; listaOrdenada.PrimeiroNo.Valor)\n            {\n                novoNo.Proximo = listaOrdenada.PrimeiroNo;\n                listaOrdenada.PrimeiroNo = novoNo;\n            }\n\n            else\n            {\n                No noBusca = listaOrdenada.PrimeiroNo;\n\n                while (noBusca.Proximo != null &amp;&amp; noBusca.Proximo.Valor &lt; novoNo.Valor)\n                    noBusca = noBusca.Proximo;\n\n                novoNo.Proximo = noBusca.Proximo;\n                noBusca.Proximo = novoNo;\n            }\n\n            noAtual = noAtual.Proximo;\n        }\n\n        return listaOrdenada;\n    }\n}\n</code></pre> <p>(5) Dado uma lista encadeada, crie uma fun\u00e7\u00e3o para realizar uma pesquisa bin\u00e1ria recursiva na mesma.</p> Pesquisa bin\u00e1ria recursiva em listas <pre><code>public class PesquisaRecursivaListaEncadeada\n{\n    public bool Pesquisar(ListaEncadeada listaEncadeada, int valorProcurado)\n    {\n        No noAtual = listaEncadeada.PegarPrimeiroNo();\n\n        return PesquisarRecursivo(noAtual, valorProcurado);\n    }\n\n    private bool PesquisarRecursivo(No noAtual, int valorProcurado)\n    {\n        if (noAtual is null)\n            return false;\n\n        if (noAtual.Valor == valorProcurado)\n            return true;\n\n        return PesquisarRecursivo(noAtual.Proximo, valorProcurado);\n    }\n}\n</code></pre> <p>(6) Dada uma lista duplamente encadeada, crie uma fun\u00e7\u00e3o recursiva para a remo\u00e7\u00e3o de seus elementos.</p> Remo\u00e7\u00e3o recursiva de lista duplamente encadeada <pre><code>public class RemocaoRecursivaListaDuplamenteEncadeada\n{\n    public NoDuplamenteEncadeado Remover(ListaDuplamenteEncadeada lista, int valor)\n    {\n        NoDuplamenteEncadeado primeiroNo = lista.PegarPrimeiroNo();\n\n        return RemoverRecursivo(lista, primeiroNo, valor);\n    }\n\n    private NoDuplamenteEncadeado RemoverRecursivo(ListaDuplamenteEncadeada lista, NoDuplamenteEncadeado noAtual, int valor)\n    {\n        if (noAtual is null)\n            return null;\n\n        if (noAtual.Valor == valor)\n        {\n            NoDuplamenteEncadeado primeiroNo = lista.PegarPrimeiroNo();\n            NoDuplamenteEncadeado ultimoNo = lista.PegarUltimoNo();\n\n            if (noAtual == primeiroNo)\n            {\n                if (noAtual.Proximo is null)\n                {\n                    lista.PrimeiroNo = null;\n                    lista.UltimoNo = null;\n                }\n\n                else\n                {\n                    lista.PrimeiroNo = noAtual.Proximo;\n                    noAtual.Proximo.Anterior = null;\n                }\n            }\n\n            else if (noAtual == ultimoNo)\n            {\n                if (noAtual.Anterior is null)\n                {\n                    lista.PrimeiroNo = null;\n                    lista.UltimoNo = null;\n                }\n\n                else\n                {\n                    lista.UltimoNo = noAtual.Anterior;\n                    noAtual.Anterior.Proximo = null;\n                }\n            }\n\n            else\n            {\n                noAtual.Anterior!.Proximo = noAtual.Proximo;\n                noAtual.Proximo!.Anterior = noAtual.Anterior;\n            }\n\n            noAtual.Proximo = null;\n            noAtual.Anterior = null;\n\n            return noAtual; \n        }\n\n        return RemoverRecursivo(lista, noAtual.Proximo, valor);\n    }\n}\n</code></pre> <p>(7) Dada uma lista duplamente encadeada, crie uma fun\u00e7\u00e3o para a remo\u00e7\u00e3o de todos os valores pares.</p> Remo\u00e7\u00e3o de n\u00fameros pares em lista duplamente encadeada <pre><code>public class RemocaoParesListaDuplamenteEncadeada\n{\n    public ListaDuplamenteEncadeada Remover(ListaDuplamenteEncadeada listaDuplamenteEncadeada)\n    {\n        NoDuplamenteEncadeado noAtual = listaDuplamenteEncadeada.PegarPrimeiroNo();\n\n        while (noAtual is not null)\n        {\n            NoDuplamenteEncadeado proximoNo = noAtual.Proximo;\n\n            if (noAtual.Valor % 2 == 0)\n                listaDuplamenteEncadeada.Remover(noAtual.Valor);\n\n            noAtual = proximoNo;\n        }\n\n        return listaDuplamenteEncadeada;\n    }\n}\n</code></pre> <p>(8) Dada uma lista duplamente encadeada, crie uma fun\u00e7\u00e3o recursiva para inverter seus elementos.</p> Invers\u00e3o recursiva de elementos em lista duplamente encadeada <pre><code>public class InversaoRecursivaListaDuplamenteEncadeada\n{\n    public ListaDuplamenteEncadeada Inverter(ListaDuplamenteEncadeada listaDuplamenteEncadeada)\n    {\n        NoDuplamenteEncadeado primeiroNo = listaDuplamenteEncadeada.PegarPrimeiroNo();\n\n        if (primeiroNo is null)\n            return listaDuplamenteEncadeada;\n\n        InverterRecursivo(primeiroNo, listaDuplamenteEncadeada);\n\n        NoDuplamenteEncadeado noTemporario = listaDuplamenteEncadeada.PrimeiroNo;\n        listaDuplamenteEncadeada.PrimeiroNo = listaDuplamenteEncadeada.UltimoNo;\n        listaDuplamenteEncadeada.UltimoNo = noTemporario;\n\n        return listaDuplamenteEncadeada;\n    }\n\n    private ListaDuplamenteEncadeada InverterRecursivo(NoDuplamenteEncadeado noAtual, ListaDuplamenteEncadeada listaDuplamenteEncadeada)\n    {\n        NoDuplamenteEncadeado noTemporario = noAtual.Proximo;\n        noAtual.Proximo = noAtual.Anterior;\n        noAtual.Anterior = noTemporario;\n\n        if (noAtual.Anterior is null)\n            return listaDuplamenteEncadeada;\n\n        return InverterRecursivo(noAtual.Anterior, listaDuplamenteEncadeada);\n    }\n}\n</code></pre> <p>(9) Dada uma lista duplamente encadeada, ordene seus elementos de forma decrescente usando o m\u00e9todo de ordena\u00e7\u00e3o r\u00e1pida (quick sort).</p> Ordena\u00e7\u00e3o decrescente com Quick Sort de lista duplamente encadeada <pre><code>public class QuickSortDecrescenteListaDuplamenteEncadeada\n{\n    public ListaDuplamenteEncadeada QuickSortDecrescente(ListaDuplamenteEncadeada listaParaOrdenacao)\n    {\n        NoDuplamenteEncadeado primeiroNo = listaParaOrdenacao.PegarPrimeiroNo();\n\n        if (primeiroNo is null)\n            return listaParaOrdenacao;\n\n        NoDuplamenteEncadeado ultimoNo = listaParaOrdenacao.PegarUltimoNo();\n\n        OrdenarComQuickSort(primeiroNo, ultimoNo, listaParaOrdenacao);\n\n        return listaParaOrdenacao;\n    }\n\n    private void OrdenarComQuickSort(NoDuplamenteEncadeado inicio, NoDuplamenteEncadeado fim, ListaDuplamenteEncadeada listaParaOrdenacao)\n    {\n        if (inicio is null || fim is null || inicio == fim || inicio.Anterior == fim)\n            return;\n\n        NoDuplamenteEncadeado pivo = Particionar(inicio, fim);\n\n        if (pivo.Anterior is not null)\n            OrdenarComQuickSort(inicio, pivo.Anterior, listaParaOrdenacao);\n        if (pivo.Proximo is not null)\n            OrdenarComQuickSort(pivo.Proximo, fim, listaParaOrdenacao);\n    }\n\n    private NoDuplamenteEncadeado Particionar(NoDuplamenteEncadeado inicio, NoDuplamenteEncadeado fim)\n    {\n        int valorPivo = fim.Valor;\n        NoDuplamenteEncadeado? noMenor = inicio.Anterior;\n        NoDuplamenteEncadeado noAtual = inicio;\n\n        while (noAtual != fim)\n        {\n            if (noAtual.Valor &gt;= valorPivo)\n            {\n                if(noMenor is null)\n                    noMenor = inicio;\n\n                else\n                    noMenor = noMenor.Proximo;\n\n                Trocar(noMenor!, noAtual);\n            }\n            noAtual = noAtual.Proximo!;\n        }\n\n        if (noMenor is null)\n            noMenor = inicio;\n\n        else\n            noMenor = noMenor.Proximo;\n\n        Trocar(noMenor, fim);\n\n        return noMenor;\n    }\n\n    private void Trocar(NoDuplamenteEncadeado noA, NoDuplamenteEncadeado noB)\n    {\n        int valorTemp = noA.Valor;\n        noA.Valor = noB.Valor;\n        noB.Valor = valorTemp;\n    }\n}\n</code></pre> <p>(10) Dada uma lista duplamente encadeada ordenada, implemente uma fun\u00e7\u00e3o recursiva que realize a busca bin\u00e1ria de um valor espec\u00edfico.</p> Pesquisa bin\u00e1ria recursiva em lista duplamente encadeada <pre><code>public class PesquisaBinariaListaDuplamenteEncadeada\n{\n    public bool Pesquisar(ListaDuplamenteEncadeada listaParaProcura, int valorProcurado)\n    {\n        NoDuplamenteEncadeado primeiroNo = listaParaProcura.PegarPrimeiroNo();\n        NoDuplamenteEncadeado ultimoNo = listaParaProcura.PegarUltimoNo();\n\n        return PesquisaBinariaRecursiva(primeiroNo, ultimoNo, valorProcurado);\n    }\n\n    private bool PesquisaBinariaRecursiva(NoDuplamenteEncadeado noInicial, NoDuplamenteEncadeado noFinal, int valorProcurado)\n    {\n        if (noInicial is null || noFinal is null)\n            return false;\n\n        NoDuplamenteEncadeado atual = noInicial;\n\n        while (atual is not null &amp;&amp; atual != noFinal)\n            atual = atual.Proximo;\n\n        if (atual != noFinal)\n            return false;\n\n        NoDuplamenteEncadeado ponteiroInicio = noInicial;\n        NoDuplamenteEncadeado ponteiroFim = noFinal;\n\n        while (ponteiroInicio != ponteiroFim &amp;&amp; ponteiroInicio.Proximo != ponteiroFim)\n        {\n            ponteiroInicio = ponteiroInicio?.Proximo;\n            ponteiroFim = ponteiroFim?.Anterior;\n        }\n\n        NoDuplamenteEncadeado noMeio = ponteiroInicio;\n\n        if (noMeio is null)\n            return false;\n\n        if (noMeio.Valor == valorProcurado)\n            return true;\n\n        if (valorProcurado &lt; noMeio.Valor)\n            return PesquisaBinariaRecursiva(noMeio.Proximo, noFinal, valorProcurado);\n\n        return PesquisaBinariaRecursiva(noInicial, noMeio.Anterior, valorProcurado);\n    }\n}\n</code></pre> <p>(11) Dada uma lista circular, implemente uma fun\u00e7\u00e3o que percorra seus n\u00f3s e retorne a quantidade total de elementos presentes na lista.</p> Quantidade de n\u00f3s em lista circular <pre><code>public class QuantidadeNosListaCircular\n{\n    public int ContarQuantidadeNos(ListaCircularDuplamenteEncadeada listaCircularDuplamenteEncadeada)\n    {\n        NoCircular noAtual = listaCircularDuplamenteEncadeada.PrimeiroNo;\n\n        if(noAtual is null)\n            return 0;\n\n        NoCircular primeiroNo = noAtual;\n        int quantidadeNos = 0;\n\n        while (noAtual.Proximo != primeiroNo)\n        {\n            quantidadeNos = quantidadeNos + 1;\n            noAtual = noAtual.Proximo;\n        }\n\n        return quantidadeNos + 1;\n    }\n}\n</code></pre> <p>(12) Dada uma lista circular, crie uma fun\u00e7\u00e3o para procurar recursivamente um elemento.</p> Pesquisa recursiva em lista circular <pre><code>public class PesquisaRecursivaListaCircular\n{\n    public bool Pesquisar(ListaCircularDuplamenteEncadeada listaCircularDuplamenteEncadeada, int valorProcurado)\n    {\n        NoCircular noAtual = listaCircularDuplamenteEncadeada.PrimeiroNo;\n\n        if (noAtual is null) \n            return false;\n\n        return PesquisarRecursivo(noAtual, noAtual, valorProcurado);\n    }\n\n    private bool PesquisarRecursivo(NoCircular noAtual, NoCircular primeiroNo, int valorProcurado)\n    {\n        if (noAtual.Valor == valorProcurado)\n            return true;\n\n        if(noAtual.Proximo == primeiroNo)\n            return false;\n\n        return PesquisarRecursivo(noAtual.Proximo, primeiroNo, valorProcurado);\n    }\n}\n</code></pre> <p>(13) Dada uma lista circular, implemente uma fun\u00e7\u00e3o que percorra a lista e remova todos os n\u00f3s cujo valor seja m\u00faltiplo de 5.</p> Removendo m\u00faltiplos de 5 em lista circular <pre><code>public class RemoveMultiploDeCincoListaCircular\n{\n    public ListaCircularDuplamenteEncadeada RemoverMultiploDeCinco(ListaCircularDuplamenteEncadeada listaCircular)\n    {\n        NoCircular noAtual = listaCircular.PrimeiroNo;\n        NoCircular primeiroNo = noAtual;\n\n        while (noAtual.Proximo is not null &amp;&amp; (noAtual.Proximo != primeiroNo || noAtual.Valor % 5 == 0))\n        {\n            if (noAtual.Valor % 5 == 0)\n            {\n                NoCircular proximoNo = noAtual.Proximo;\n                listaCircular.Remover(noAtual.Valor);\n\n                if (noAtual.Valor == primeiroNo.Valor)\n                    primeiroNo = proximoNo;\n\n                noAtual = proximoNo;\n            }\n\n            else\n                noAtual = noAtual.Proximo;\n\n        }\n\n        return listaCircular;\n    }\n}\n</code></pre> <p>(14) Dada uma lista circular, crie uma fun\u00e7\u00e3o que rotacione os elementos da lista circular N posi\u00e7\u00f5es.</p> Rota\u00e7\u00e3o de elementos em lista circular <pre><code>public class RotacaoListaCircular\n{\n    public ListaCircularDuplamenteEncadeada Rotacionar(ListaCircularDuplamenteEncadeada listaCircular, int quantidadeRotacoes)\n    {\n        NoCircular noAtual = listaCircular.PrimeiroNo;\n\n        for (int i = 0; i &lt; quantidadeRotacoes; i++)\n            noAtual = noAtual.Proximo;            \n\n        listaCircular.PrimeiroNo = noAtual;\n\n        return listaCircular;\n    }\n}\n</code></pre> <p>(15) Dada uma lista circular, use o Merge Sort para ordenar seus elementos.</p> Merge Sort em lista circular <pre><code>public class MergeSortListaCircular\n{\n    public ListaCircularDuplamenteEncadeada Ordenar(ListaCircularDuplamenteEncadeada listaCircularOriginal)\n    {\n        NoCircular primeiroNo = listaCircularOriginal.PegarPrimeiroNo();\n\n        if (primeiroNo is null || primeiroNo.Proximo == primeiroNo)\n            return listaCircularOriginal;\n\n        ListaCircularDuplamenteEncadeada nosEsquerda = new ListaCircularDuplamenteEncadeada();\n        ListaCircularDuplamenteEncadeada nosDireita = new ListaCircularDuplamenteEncadeada();\n\n        DividirListaAoMeio(listaCircularOriginal, nosEsquerda, nosDireita);\n\n        ListaCircularDuplamenteEncadeada primeiraMetadeOrdenada = Ordenar(nosEsquerda);\n        ListaCircularDuplamenteEncadeada segundaMetadeOrdenada = Ordenar(nosDireita);\n\n        return JuntarListasOrdenadas(primeiraMetadeOrdenada, segundaMetadeOrdenada);\n    }\n\n    private void DividirListaAoMeio(ListaCircularDuplamenteEncadeada listaOriginal,\n        ListaCircularDuplamenteEncadeada nosEsquerda,\n        ListaCircularDuplamenteEncadeada nosDireita)\n    {\n        NoCircular ponteiroParaInicio = listaOriginal.PrimeiroNo;\n        NoCircular ponteiroParaFinal = listaOriginal.PrimeiroNo;\n\n        while (\n            ponteiroParaFinal.Proximo != listaOriginal.PrimeiroNo &amp;&amp;\n            ponteiroParaFinal.Proximo.Proximo != listaOriginal.PrimeiroNo)\n        {\n            ponteiroParaInicio = ponteiroParaInicio.Proximo;\n            ponteiroParaFinal = ponteiroParaFinal.Proximo.Proximo;\n        }\n\n        NoCircular ultimoNoEsquerda = ponteiroParaInicio;\n        NoCircular noAtual = listaOriginal.PrimeiroNo;\n\n        while (noAtual != ultimoNoEsquerda.Proximo)\n        {\n            nosEsquerda.AdicionarNoFim(noAtual.Valor);\n            noAtual = noAtual.Proximo;\n        }\n\n        while (noAtual != listaOriginal.PrimeiroNo)\n        {\n            nosDireita.AdicionarNoFim(noAtual.Valor);\n            noAtual = noAtual.Proximo;\n        }\n    }\n\n    private ListaCircularDuplamenteEncadeada JuntarListasOrdenadas(\n        ListaCircularDuplamenteEncadeada nosEsquerda,\n        ListaCircularDuplamenteEncadeada nosDireita)\n    {\n        ListaCircularDuplamenteEncadeada listaOrdenada = new ListaCircularDuplamenteEncadeada();\n\n        NoCircular noAtualEsquerda = nosEsquerda.PrimeiroNo;\n        NoCircular noAtualDireita = nosDireita.PrimeiroNo;\n\n        int totalNosEsquerda = PegarQuantidadeDeNos(nosEsquerda);\n        int totalNosDireita = PegarQuantidadeDeNos(nosDireita);\n\n        int contadorNosEsquerda = 0;\n        int contadorNosDireita = 0;\n\n        while (contadorNosEsquerda &lt; totalNosEsquerda || contadorNosDireita &lt; totalNosDireita)\n        {\n            bool deveAdicionarDaPrimeiraLista = false;\n\n            if (contadorNosEsquerda &lt; totalNosEsquerda &amp;&amp; (contadorNosDireita &gt;= totalNosDireita || noAtualEsquerda.Valor &lt;= noAtualDireita.Valor))\n                deveAdicionarDaPrimeiraLista = true;\n\n            if (deveAdicionarDaPrimeiraLista)\n            {\n                listaOrdenada.AdicionarNoFim(noAtualEsquerda.Valor);\n                noAtualEsquerda = noAtualEsquerda.Proximo;\n                contadorNosEsquerda = contadorNosEsquerda + 1;\n            }\n            else\n            {\n                listaOrdenada.AdicionarNoFim(noAtualDireita.Valor);\n                noAtualDireita = noAtualDireita.Proximo;\n                contadorNosDireita = contadorNosDireita + 1;\n            }\n        }\n\n        return listaOrdenada;\n    }\n\n    private int PegarQuantidadeDeNos(ListaCircularDuplamenteEncadeada listaCircular)\n    {\n        if (listaCircular.PrimeiroNo is null)\n            return 0;\n\n        int quantidadeNos = 1;\n        NoCircular noAtual = listaCircular.PrimeiroNo.Proximo;\n\n        while (noAtual != listaCircular.PrimeiroNo)\n        {\n            quantidadeNos = quantidadeNos + 1;\n            noAtual = noAtual.Proximo;\n        }\n\n        return quantidadeNos;\n    }\n}\n</code></pre>"},{"location":"listas/listas-circulares-duplamente-encadeadas/","title":"Listas circulares duplamente encadeadas","text":"<p>Uma lista circular duplamente encadeada \u00e9 semelhante a uma lista duplamente encadeada, com a diferen\u00e7a de que a refer\u00eancia que aponta para o elemento anterior do primeiro n\u00f3 passa a apontar para o \u00faltimo n\u00f3, e a refer\u00eancia que aponta para o pr\u00f3ximo n\u00f3 do \u00faltimo n\u00f3 passa a apontar para o primeiro n\u00f3 da lista. Com essa estrutura circular, n\u00e3o \u00e9 necess\u00e1rio manter uma vari\u00e1vel separada para o \u00faltimo n\u00f3.</p> <p>Uso no dia-a-dia</p> <p>Listas circulares duplamente encadeadas s\u00e3o amplamente utilizadas em cen\u00e1rios que exigem percursos cont\u00ednuos e c\u00edclicos sobre os dados, como em sistemas de escalonamento de processos (Round-Robin), comunica\u00e7\u00e3o em tempo real, balanceamento de carga, entre outros.</p>"},{"location":"listas/listas-circulares-duplamente-encadeadas/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<p>Observe que, ao inicializar um n\u00f3, ele \u00e9 configurado para apontar para si mesmo, tanto no ponteiro <code>Proximo</code> quanto no ponteiro <code>Anterior</code>, garantindo a circularidade da lista desde o in\u00edcio. Vamos chamar esse n\u00f3 de <code>NoCircular</code>.</p> <pre><code>public class NoCircular\n {\n     public int Valor;\n     public NoCircular Proximo;\n     public NoCircular Anterior;\n\n     public NoCircular(int valor)\n     {\n         Valor = valor;\n         Proximo = this;\n         Anterior = this;\n     }\n }\n</code></pre> <pre><code>public class ListaCircularDuplamenteEncadeada\n{\n    public NoCircular? PrimeiroNo;\n\n    public NoCircular PegarPrimeiroNo() =&gt; PrimeiroNo;\n\n    public NoCircular AdicionarNoInicio(int valor)\n    {\n        NoCircular novoNo = new NoCircular(valor);\n\n        if (PrimeiroNo is null)            \n            PrimeiroNo = novoNo;\n\n        else\n        {\n            NoCircular ultimoNo = PrimeiroNo.Anterior;\n\n            novoNo.Proximo = PrimeiroNo;\n            novoNo.Anterior = ultimoNo;\n\n            PrimeiroNo.Anterior = novoNo;\n            ultimoNo.Proximo = novoNo;\n\n            PrimeiroNo = novoNo;\n        }\n\n        return novoNo;  \n    }\n\n    public NoCircular AdicionarNoFim(int valor)\n    {\n        NoCircular novoNo = new NoCircular(valor);\n\n        if (PrimeiroNo is null)            \n            PrimeiroNo = novoNo;\n\n        else\n        {\n            NoCircular ultimoNo = PrimeiroNo.Anterior;\n\n            novoNo.Proximo = PrimeiroNo;\n            novoNo.Anterior = ultimoNo;\n\n            ultimoNo.Proximo = novoNo;\n            PrimeiroNo.Anterior = novoNo;\n        }\n\n        return novoNo;  \n    }\n\n    public NoCircular Remover(int valor)\n    {\n        if (PrimeiroNo is null)\n            return null;\n\n        NoCircular noAtual = PrimeiroNo;\n\n        do\n        {\n            if (noAtual.Valor == valor)\n            {\n                if (noAtual.Proximo == noAtual)                    \n                    PrimeiroNo = null;\n\n                else\n                {\n                    noAtual.Anterior.Proximo = noAtual.Proximo;\n                    noAtual.Proximo.Anterior = noAtual.Anterior;\n\n                    if (noAtual == PrimeiroNo)\n                        PrimeiroNo = noAtual.Proximo;\n                }\n\n                noAtual.Proximo = null;\n                noAtual.Anterior = null;\n\n                return noAtual; \n            }\n\n            noAtual = noAtual.Proximo;\n        } while (noAtual != PrimeiroNo);\n\n        return null;  \n    }\n}\n</code></pre> Lista circular duplamente encadeada <p></p>"},{"location":"listas/listas-duplamente-encadeadas-operacoes-c-sharp/","title":"Listas duplamente encadeadas padr\u00e3o em C#","text":"<p>A linguagem C# oferece uma implementa\u00e7\u00e3o pronta de lista duplamente encadeada por meio da classe <code>LinkedList&lt;T&gt;</code>, dispon\u00edvel no namespace <code>System.Collections.Generic</code>. Essa estrutura fornece opera\u00e7\u00f5es essenciais, como <code>AddFirst</code> e <code>AddLast</code> para inser\u00e7\u00e3o de elementos no in\u00edcio ou no final da lista, respectivamente. Para remo\u00e7\u00e3o, podemos utilizar <code>RemoveFirst</code>, <code>RemoveLast</code> ou <code>Remove</code>, que permite remo\u00e7\u00e3o de n\u00f3s no in\u00edcio, final e um n\u00f3 espec\u00edfico em qualquer posi\u00e7\u00e3o da lista. Todo o controle interno \u2014 incluindo a aloca\u00e7\u00e3o de mem\u00f3ria e o encadeamento dos elementos \u2014 \u00e9 gerenciado automaticamente pela pr\u00f3pria estrutura da linguagem, o que facilita seu uso e reduz a complexidade da implementa\u00e7\u00e3o manual.</p> <p>As opera\u00e7\u00f5es de adi\u00e7\u00e3o retornam um n\u00f3 j\u00e1 implementado pela linguagem, representado pela classe <code>LinkedListNode&lt;T&gt;</code>. Essa classe permite navegar pela estrutura encadeada: o pr\u00f3ximo n\u00f3 pode ser acessado por meio da propriedade <code>Next</code>, o n\u00f3 anterior por <code>Previous</code> e o valor armazenado no n\u00f3 por meio da propriedade <code>Value</code>.</p>"},{"location":"listas/listas-duplamente-encadeadas-operacoes-c-sharp/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<pre><code>public class ListaDuplamenteEncadeadaPadrao\n{\n    private LinkedList&lt;int&gt; _listaDuplamenteEncadeada;\n\n    public ListaDuplamenteEncadeadaPadrao()        \n        =&gt; _listaDuplamenteEncadeada = new LinkedList&lt;int&gt;();        \n\n    public LinkedListNode&lt;int&gt; PrimeiroNo =&gt; _listaDuplamenteEncadeada.First;\n\n    public LinkedListNode&lt;int&gt; UltimoNo =&gt; _listaDuplamenteEncadeada.Last;\n\n    public LinkedListNode&lt;int&gt; AdicionarNoInicio(int valor)\n        =&gt;  _listaDuplamenteEncadeada.AddFirst(valor);        \n\n    public LinkedListNode&lt;int&gt; AdicionarNoFinal(int valor)\n        =&gt; _listaDuplamenteEncadeada.AddLast(valor);\n\n    public void RemoverNoInicio()\n        =&gt; _listaDuplamenteEncadeada.RemoveFirst();\n\n    public void RemoverNoFinal()\n        =&gt; _listaDuplamenteEncadeada.RemoveLast();\n\n    public LinkedListNode&lt;int&gt; Remover(int valor)\n    {\n        LinkedListNode&lt;int&gt; noAtual = _listaDuplamenteEncadeada.First;\n\n        while (noAtual != null)\n        {\n            if (noAtual.Value == valor)\n            {\n                _listaDuplamenteEncadeada.Remove(noAtual);\n                return noAtual;\n            }\n\n            noAtual = noAtual.Next;\n        }\n\n        return null;\n    }\n}\n</code></pre> Inser\u00e7\u00e3o de n\u00f3sRemo\u00e7\u00e3o de n\u00f3s"},{"location":"listas/listas-duplamente-encadeadas-operacoes/","title":"Listas duplamente encadeadas e suas opera\u00e7\u00f5es","text":"<p>Uma lista duplamente encadeada \u00e9 uma estrutura de dados linear e din\u00e2mica, composta por n\u00f3s. A diferen\u00e7a dela para a lista simplesmente encadeada \u00e9 que cada n\u00f3 possui um ponteiro para o n\u00f3 posterior e anterior. Isso permite percorrer a lista tanto para frente quanto para tr\u00e1s.</p>"},{"location":"listas/listas-duplamente-encadeadas-operacoes/#insercao-de-nos","title":"Inser\u00e7\u00e3o de n\u00f3s","text":"<p>A inser\u00e7\u00e3o no in\u00edcio e no fim de uma lista duplamente encadeada possui complexidade <code>O(1)</code>, pois s\u00e3o mantidas refer\u00eancias separadas para o primeiro e o \u00faltimo n\u00f3 da lista. Isso permite adicionar elementos diretamente nessas posi\u00e7\u00f5es sem percorrer a estrutura. J\u00e1 para inserir em uma posi\u00e7\u00e3o intermedi\u00e1ria, \u00e9 necess\u00e1rio percorrer a lista at\u00e9 o ponto desejado, o que resulta em uma complexidade <code>O(n)</code>.</p> Caso Complexidade Melhor caso O(1) Caso m\u00e9dio O(n) Pior caso O(n)"},{"location":"listas/listas-duplamente-encadeadas-operacoes/#remocao-de-nos","title":"Remo\u00e7\u00e3o de n\u00f3s","text":"<p>A remo\u00e7\u00e3o no in\u00edcio e no fim de uma lista duplamente encadeada possui complexidade <code>O(1)</code>, pois s\u00e3o mantidas refer\u00eancias diretas para o primeiro e o \u00faltimo n\u00f3, permitindo a exclus\u00e3o imediata dessas posi\u00e7\u00f5es. J\u00e1 a remo\u00e7\u00e3o de um elemento no meio da lista exige um percurso at\u00e9 o n\u00f3 desejado, resultando em uma complexidade <code>O(n)</code>.</p> Caso Complexidade Melhor caso O(1) Caso m\u00e9dio O(n) Pior caso O(n)"},{"location":"listas/listas-duplamente-encadeadas-operacoes/#pesquisa-de-valores","title":"Pesquisa de valores","text":"<p>Para encontrar um elemento em uma lista duplamente encadeada, \u00e9 necess\u00e1rio percorr\u00ea-la a partir do in\u00edcio. Se o elemento estiver no primeiro n\u00f3, a busca ter\u00e1 complexidade <code>O(1)</code>. No pior caso, ser\u00e1 necess\u00e1rio percorrer toda a lista, resultando em uma complexidade <code>O(n)</code>.</p> Caso Complexidade Melhor caso O(1) Caso m\u00e9dio O(n) Pior caso O(n) <p>Uso no dia-a-dia</p> <p>Listas duplamente encadeadas s\u00e3o amplamente utilizadas em diversos cen\u00e1rios, como o gerenciamento de processos em sistemas operacionais, a gest\u00e3o de mem\u00f3ria, sistemas de edi\u00e7\u00e3o de texto e outras aplica\u00e7\u00f5es que exigem manipula\u00e7\u00e3o eficiente e bidirecional de dados.</p>"},{"location":"listas/listas-duplamente-encadeadas-operacoes/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<p>Note o novo atributo que referencia o n\u00f3 anterior. Chamaremos essa estrutura de <code>NoDuplamenteEncadeado</code>.</p> <pre><code>public class NoDuplamenteEncadeado\n{\n    public int Valor;\n    public NoDuplamenteEncadeado? Proximo;\n    public NoDuplamenteEncadeado? Anterior;\n\n    public NoDuplamenteEncadeado(int valor)\n    {\n        Valor = valor;\n        Proximo = null;\n        Anterior = null;\n    }\n}\n</code></pre> <pre><code>ppublic class ListaDuplamenteEncadeada\n{\n    public NoDuplamenteEncadeado PrimeiroNo;\n    public NoDuplamenteEncadeado UltimoNo;\n\n    public NoDuplamenteEncadeado? PegarPrimeiroNo() =&gt; PrimeiroNo;\n\n    public NoDuplamenteEncadeado? PegarUltimoNo() =&gt; UltimoNo;\n\n    public NoDuplamenteEncadeado AdicionarNoInicio(int valor)\n    {\n        NoDuplamenteEncadeado novoNo = new NoDuplamenteEncadeado(valor);\n\n        if (PrimeiroNo is null)\n        {\n            novoNo.Proximo = null;\n            novoNo.Anterior = null;\n\n            PrimeiroNo = novoNo;\n            UltimoNo = novoNo;\n        }\n        else\n        {\n            novoNo.Proximo = PrimeiroNo;\n            novoNo.Anterior = null;\n\n            PrimeiroNo.Anterior = novoNo;\n            PrimeiroNo = novoNo;\n        }\n\n        return novoNo;\n    }\n\n    public NoDuplamenteEncadeado AdicionarNoFinal(int valor)\n    {\n        NoDuplamenteEncadeado novoNo = new NoDuplamenteEncadeado(valor);\n\n        if (UltimoNo is null)\n        {\n            novoNo.Proximo = null;\n            novoNo.Anterior = null;\n\n            PrimeiroNo = novoNo;\n            UltimoNo = novoNo;\n        }\n        else\n        {\n            novoNo.Anterior = UltimoNo;\n            novoNo.Proximo = null;\n\n            UltimoNo.Proximo = novoNo;\n            UltimoNo = novoNo;\n        }\n\n        return novoNo;\n    }\n\n    public NoDuplamenteEncadeado Remover(int valor)\n    {\n        NoDuplamenteEncadeado noAtual = PrimeiroNo;\n\n        while (noAtual is not null)\n        {\n            if (noAtual.Valor == valor)\n            {\n                if (noAtual == PrimeiroNo)\n                {\n                    PrimeiroNo = PrimeiroNo.Proximo;\n\n                    if (PrimeiroNo is not null)\n                        PrimeiroNo.Anterior = null;\n\n                    else\n                        UltimoNo = null;\n                }\n\n                else if (noAtual == UltimoNo)\n                {\n                    UltimoNo = UltimoNo.Anterior;\n\n                    if (UltimoNo is not null)\n                        UltimoNo.Proximo = null;\n\n                    else\n                        PrimeiroNo = null;\n                }\n\n                else\n                {\n                    noAtual.Anterior!.Proximo = noAtual.Proximo;\n                    noAtual.Proximo!.Anterior = noAtual.Anterior;\n                }\n\n                noAtual.Proximo = null;\n                noAtual.Anterior = null;\n\n                return noAtual;\n            }\n\n            noAtual = noAtual.Proximo;\n        }\n\n        return null;\n    }\n}\n</code></pre> Inser\u00e7\u00e3o de n\u00f3sRemo\u00e7\u00e3o de n\u00f3s <p></p> <p></p>"},{"location":"listas/listas-encadeadas-operacoes-c-sharp/","title":"Listas encadeadas padr\u00e3o em C#","text":"<p>A linguagem C# disponibiliza uma estrutura de lista pronta por meio da classe <code>List&lt;T&gt;</code>, presente no namespace <code>System.Collections.Generic</code>. Essa estrutura oferece opera\u00e7\u00f5es fundamentais, como <code>Add</code> para inser\u00e7\u00e3o de elementos e <code>Remove</code> para remo\u00e7\u00e3o. Todo o gerenciamento interno \u2014 como aloca\u00e7\u00e3o de mem\u00f3ria e reorganiza\u00e7\u00e3o dos elementos \u2014 \u00e9 automaticamente tratado pela pr\u00f3pria implementa\u00e7\u00e3o da linguagem.</p>"},{"location":"listas/listas-encadeadas-operacoes-c-sharp/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<pre><code>public class ListaEncadeadaPadrao\n{\n    private List&lt;int&gt; Numeros;\n\n    public ListaEncadeadaPadrao()\n        =&gt; Numeros = new List&lt;int&gt;();        \n\n    public void Adicionar(int valor)\n        =&gt; Numeros.Add(valor);\n\n    public bool Remover(int valor)\n        =&gt; Numeros.Remove(valor);\n}\n</code></pre> Inicializando uma listaInser\u00e7\u00e3o de n\u00f3sRemo\u00e7\u00e3o de n\u00f3s"},{"location":"listas/listas-encadeadas-operacoes/","title":"Listas encadeadas e suas opera\u00e7\u00f5es","text":"<p>Uma lista encadeada \u00e9 uma estrutura de dados onde os elementos, chamados de n\u00f3s, s\u00e3o organizados de forma linear. Diferente de um array, a ordem dos elementos n\u00e3o depende de posi\u00e7\u00f5es fixas na mem\u00f3ria, mas sim de ponteiros (ou refer\u00eancias) que conectam um n\u00f3 ao pr\u00f3ximo.</p> <p>Cada n\u00f3 armazena dois dados principais:</p> <ol> <li> <p>O valor em si (como um n\u00famero ou uma string),</p> </li> <li> <p>Um ponteiro para o pr\u00f3ximo n\u00f3 da lista.</p> </li> </ol> <p>Essa estrutura \u00e9 din\u00e2mica, o que significa que ela pode crescer com novas inser\u00e7\u00f5es e diminuir com remo\u00e7\u00f5es, sem a necessidade de criar c\u00f3pias ou redefinir o tamanho da lista \u2014 ao contr\u00e1rio do que acontece com arrays fixos.</p> <p>A flexibilidade da lista encadeada a torna ideal para situa\u00e7\u00f5es onde o n\u00famero de elementos pode variar bastante durante a execu\u00e7\u00e3o do programa.</p>"},{"location":"listas/listas-encadeadas-operacoes/#insercao-de-nos","title":"Inser\u00e7\u00e3o de n\u00f3s","text":"<p>A inser\u00e7\u00e3o de um novo n\u00f3 no in\u00edcio de uma lista encadeada tem complexidade <code>O(1)</code>. Isso porque basta criar um novo n\u00f3 e fazer com que ele aponte para o antigo primeiro n\u00f3 \u2014 um processo direto, que n\u00e3o depende do tamanho da lista.</p> <p>J\u00e1 a inser\u00e7\u00e3o no final de uma lista simplesmente encadeada, em geral, tem complexidade <code>O(n)</code>, pois \u00e9 necess\u00e1rio percorrer toda a lista at\u00e9 encontrar o \u00faltimo n\u00f3. Contudo, se a lista mantiver uma refer\u00eancia direta para o \u00faltimo n\u00f3 (como em uma implementa\u00e7\u00e3o com ponteiro para o tail), essa opera\u00e7\u00e3o pode ser otimizada para <code>O(1)</code>.</p> <p>Por fim, inserir em uma posi\u00e7\u00e3o espec\u00edfica exige percorrer a lista at\u00e9 o ponto desejado, o que resulta em complexidade <code>O(n)</code>, j\u00e1 que, em m\u00e9dia, \u00e9 necess\u00e1rio visitar metade dos elementos.</p> Caso Complexidade Melhor caso O(1) Caso m\u00e9dio O(n) Pior caso O(n)"},{"location":"listas/listas-encadeadas-operacoes/#remocao-de-nos","title":"Remo\u00e7\u00e3o de n\u00f3s","text":"<p>Remover um n\u00f3 do in\u00edcio de uma lista encadeada \u00e9 uma opera\u00e7\u00e3o de complexidade <code>O(1)</code>. Isso ocorre porque basta atualizar o ponteiro do primeiro n\u00f3 para apontar para o segundo \u2014 uma a\u00e7\u00e3o direta, independente do tamanho da lista.</p> <p>Por outro lado, a remo\u00e7\u00e3o de um n\u00f3 em uma posi\u00e7\u00e3o espec\u00edfica ou no final da lista exige percorrer os elementos at\u00e9 o ponto desejado. Como n\u00e3o h\u00e1 acesso direto aos n\u00f3s anteriores, \u00e9 necess\u00e1rio visitar cada um sequencialmente at\u00e9 chegar ao n\u00f3 anterior ao que ser\u00e1 removido, apresentando complexidade <code>O(n)</code>.</p> Caso Complexidade Melhor caso O(1) Caso m\u00e9dio O(n) Pior caso O(n)"},{"location":"listas/listas-encadeadas-operacoes/#pesquisa-de-dados","title":"Pesquisa de dados","text":"<p>Como os elementos de uma lista encadeada n\u00e3o est\u00e3o armazenados de forma cont\u00edgua na mem\u00f3ria, n\u00e3o \u00e9 poss\u00edvel acessar diretamente um n\u00f3 espec\u00edfico. Para encontrar um valor, \u00e9 necess\u00e1rio percorrer a lista a partir do primeiro n\u00f3, um a um, at\u00e9 localizar o dado desejado ou atingir o final da lista.</p> <p>Portanto, a complexidade da opera\u00e7\u00e3o de busca \u00e9 <code>O(n)</code>, onde <code>n</code> representa o n\u00famero de elementos da lista.</p> Caso Complexidade Melhor caso O(1) Caso m\u00e9dio O(n) Pior caso O(n) <p>Uso no dia-a-dia</p> <p>Listas encadeadas s\u00e3o amplamente utilizadas em diversos cen\u00e1rios que envolvem estruturas din\u00e2micas, como listas de reprodu\u00e7\u00e3o de m\u00fasicas, carrinhos de compras em plataformas de e-commerce, e gerenciamento de filas de voos em aeroportos, entre outros contextos em que inser\u00e7\u00f5es e remo\u00e7\u00f5es frequentes de elementos s\u00e3o comuns.</p>"},{"location":"listas/listas-encadeadas-operacoes/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<p>Uma lista encadeada \u00e9 formada por elementos chamados de n\u00f3s. Por isso, o primeiro passo para sua implementa\u00e7\u00e3o \u00e9 criar a classe que representa esses n\u00f3s.</p> <pre><code>public class No\n{\n    public int Valor;\n    public No Proximo;\n\n    public No(int valor)\n    {\n        Valor = valor;\n        Proximo = null;            \n    }\n}\n</code></pre> <p>Agora que temos a estrutura dos n\u00f3s definida, podemos come\u00e7ar a construir a nossa lista encadeada.</p> <pre><code>public class ListaEncadeada\n{\n    public No PrimeiroNo;\n\n    public ListaEncadeada()\n        =&gt; PrimeiroNo = null;\n\n    public No PegarPrimeiroNo() =&gt; PrimeiroNo;\n    public No AdicionarNoInicio(int valor)\n    {\n        No novoNo = new No(valor);\n        novoNo.Proximo = PrimeiroNo;\n        PrimeiroNo = novoNo;\n\n        return PrimeiroNo;\n    }\n\n    public No AdicionarNoFim(int valor)\n    {\n        No novoNo = new No(valor);\n\n        if (PrimeiroNo is null)\n        {\n            PrimeiroNo = novoNo;\n            return novoNo;\n        }\n\n        No noAtual = PrimeiroNo;\n\n        while (noAtual.Proximo is not null)\n            noAtual = noAtual.Proximo;\n\n        noAtual.Proximo = novoNo;\n\n        return novoNo;\n    }\n\n    public No RemoverNoInicio()\n    {\n        if (PrimeiroNo is null)\n            return null;\n\n        No noRemovido = PrimeiroNo;\n        PrimeiroNo = PrimeiroNo.Proximo;\n        noRemovido.Proximo = null;\n        return noRemovido;\n    }\n\n    public No RemoverNoFim()\n    {\n        if (PrimeiroNo is null)\n            return null;\n\n        if (PrimeiroNo.Proximo is null)\n        {\n            No noUnico = PrimeiroNo;\n            PrimeiroNo = null;\n            return noUnico;\n        }\n\n        No noAtual = PrimeiroNo;\n\n        while (noAtual.Proximo.Proximo is not null)\n            noAtual = noAtual.Proximo;\n\n        No noRemovido = noAtual.Proximo;\n        noAtual.Proximo = null;\n        return noRemovido;\n    }\n\n    public No RemoverNo(int posicao)\n    {\n        if (posicao &lt; 0 || PrimeiroNo is null)\n            return null;\n\n        if (posicao == 0)\n            return RemoverNoInicio();\n\n        No noAtual = PrimeiroNo;\n        int indice = 0;\n\n        while (noAtual.Proximo is not null &amp;&amp; indice &lt; posicao - 1)\n        {\n            noAtual = noAtual.Proximo;\n            indice = indice + 1;\n        }\n\n        if (noAtual.Proximo is null)\n            return null;\n\n        No noRemovido = noAtual.Proximo;\n        noAtual.Proximo = noRemovido.Proximo;\n        noRemovido.Proximo = null;\n\n        return noRemovido;\n    }\n\n    public No Pesquisar(int valor)\n    {\n        No noAtual = PrimeiroNo;\n\n        while (noAtual is not null)\n        {\n            if (noAtual.Valor == valor)\n                return noAtual;\n\n            noAtual = noAtual.Proximo;\n        }\n\n        return null;\n    }\n\n    public int Size()\n    {\n        int quantidadeNos = 0;\n\n        No noAtual = PrimeiroNo;\n\n        while (noAtual is not null)\n        {\n            noAtual = noAtual.Proximo;\n            quantidadeNos = quantidadeNos + 1;\n        }\n\n        return quantidadeNos;\n    }\n    public bool IsEmpty()\n        =&gt; PrimeiroNo is null;\n}\n</code></pre> Inicializando uma listaInser\u00e7\u00e3o de n\u00f3sRemo\u00e7\u00e3o de n\u00f3s <p></p> <p></p> <p></p>"},{"location":"notacaoBigO/","title":"Introdu\u00e7\u00e3o \u00e0 nota\u00e7\u00e3o Big O","text":"<p>Ap\u00f3s um longo per\u00edodo de trabalho, Cristina percebeu que precisava de um respiro \u2014 algo leve e divertido. Decidiu ir ao cinema, recarregar suas energias com um filme empolgante. Pegou o carro e resolveu dirigir at\u00e9 o shopping mais pr\u00f3ximo. Mas havia um problema: era hora do rush.</p> <p>Ao pegar a avenida X, percebeu que, \u00e0 medida que novos carros surgiam, o tempo de chegada aumentava de forma exponencial. Quando passou em frente \u00e0 avenida Y, achou que poderia ser uma boa ideia tentar por l\u00e1. No entanto, assim que entrou, percebeu que o n\u00famero de carros havia dobrado \u2014 e o tempo estimado tamb\u00e9m.</p> <p>Avan\u00e7ando com um pouco de paci\u00eancia em meio \u00e0quele mar de buzinas e caos, avistou a avenida Z \u2014 larga, promissora, cheia de faixas. \"Agora o jogo vai mudar\", pensou. Mas logo veio o arrependimento: eram tantos carros que cada cruzamento parecia um labirinto. Trinta minutos se passaram, e apenas quatro quil\u00f4metros haviam sido percorridos.</p> <p>Foi ent\u00e3o que se lembrou de uma rua lateral, pouco movimentada, quase esquecida at\u00e9 pelo GPS. Apesar de mais longa, era a rota mais r\u00e1pida \u2014 e levava direto ao lado do shopping.</p> <p>Assim como escolher a melhor avenida pode significar a diferen\u00e7a entre um trajeto tranquilo e um congestionamento intermin\u00e1vel, a nota\u00e7\u00e3o Big O tamb\u00e9m nos ajuda a entender qual \u00e9 o melhor caminho \u2014 ou melhor, qual algoritmo \u00e9 o mais eficiente. Seu objetivo \u00e9 revelar, em termos de tempo e uso de recursos, qual solu\u00e7\u00e3o escala melhor \u00e0 medida que o \u201ctr\u00e2nsito\u201d de dados aumenta.</p> <p>Compreender seu funcionamento \u00e9 essencial para que possamos escolher a abordagem mais adequada nas mais variadas situa\u00e7\u00f5es.</p> <p>3.1 Como calcular o tempo de execu\u00e7\u00e3o</p>"},{"location":"notacaoBigO/calculo-tempo-execucao/","title":"Como calcular o tempo de execu\u00e7\u00e3o","text":"<p>A nota\u00e7\u00e3o Big O \u00e9 usada para descrever a efici\u00eancia de um algoritmo, especialmente em rela\u00e7\u00e3o ao tempo de execu\u00e7\u00e3o conforme o tamanho da entrada cresce.</p> <p>Imagine que voc\u00ea tem um vetor com n elementos. Se voc\u00ea precisar percorrer todo o vetor uma vez, isso exigir\u00e1 n opera\u00e7\u00f5es \u2014 logo, dizemos que o tempo de execu\u00e7\u00e3o \u00e9 <code>O(n)</code>, ou seja, linear.</p> <p>Agora, e se voc\u00ea tiver que percorrer um vetor dentro de outro vetor? Por exemplo, em um algoritmo com dois la\u00e7os aninhados. Nesse caso, para cada um dos n elementos do primeiro vetor, voc\u00ea percorre n elementos do segundo. Isso resulta em n * n opera\u00e7\u00f5es \u2014 ou seja, <code>O(n\u00b2)</code>, uma complexidade quadr\u00e1tica.</p> <p>Quando o objetivo \u00e9 procurar um elemento em um vetor, uma pesquisa linear (verificando elemento por elemento) pode ser r\u00e1pida se o item estiver logo no in\u00edcio \u2014 o que levaria <code>O(1)</code>, tempo constante. No entanto, no pior caso, pode ser necess\u00e1rio verificar todos os elementos, resultando novamente em <code>O(n)</code>.</p> <p>Mas se o vetor estiver ordenado, podemos aplicar uma pesquisa bin\u00e1ria, que a cada passo elimina metade das possibilidades. Isso torna o processo muito mais eficiente, com complexidade <code>O(log n)</code> \u2014 ou seja, mesmo que o vetor seja grande, o n\u00famero de opera\u00e7\u00f5es cresce lentamente.</p>"},{"location":"ordenacao/","title":"Introdu\u00e7\u00e3o \u00e0 ordena\u00e7\u00e3o","text":"<p>C\u00edntia \u00e9 a gerente respons\u00e1vel pelo hotel mais famoso da cidade. Sempre organizada e atenta aos detalhes, ela \u00e9 quem cuida pessoalmente da aloca\u00e7\u00e3o dos h\u00f3spedes nos quartos.</p> <p>Em um certo dia agitado, uma excurs\u00e3o inteira chegou ao hotel \u2014 um grupo animado vindo de uma ag\u00eancia de turismo. Era muita gente para distribuir rapidamente. C\u00edntia, como sempre, queria fazer isso da melhor forma poss\u00edvel. Mas como?</p> <p>Com a lista de todos os novos h\u00f3spedes em m\u00e3os, contendo nome, sexo e idade, ela teve uma ideia brilhante: ordenar os h\u00f3spedes por idade e coloc\u00e1-los nos andares do hotel conforme essa ordem. Quanto mais jovem o h\u00f3spede, mais baixo o andar. Os mais velhos ficariam nos andares mais altos, com uma bela vista da cidade.</p> <p>A primeira etapa do plano era clara: ordenar os dados pela idade. Mas logo surgiram as d\u00favidas:</p> <p>\"Ser\u00e1 que eu preciso fazer isso manualmente, um por um?\"</p> <p>\"Talvez seja melhor dividir por faixas et\u00e1rias e ordenar dentro de cada grupo?\"</p> <p>\"Devo ordenar do mais velho para o mais novo ou o contr\u00e1rio?\"</p> <p>Essas quest\u00f5es, na verdade, s\u00e3o comuns para qualquer um que lide com organiza\u00e7\u00e3o e dados. E s\u00e3o exatamente o tipo de problema que resolvemos usando algoritmos de ordena\u00e7\u00e3o.</p> <p>A partir da hist\u00f3ria de C\u00edntia, percebemos como algo simples como ordenar uma lista pode se tornar um desafio interessante, especialmente quando buscamos efici\u00eancia, clareza e organiza\u00e7\u00e3o.</p> <p>4.1 Ordena\u00e7\u00e3o usando o m\u00e9todo da bolha (Bubble Sort)</p> <p>4.2 Ordena\u00e7\u00e3o usando o m\u00e9todo de sele\u00e7\u00e3o (Selection Sort)</p> <p>4.3 Ordena\u00e7\u00e3o usando o m\u00e9todo de inser\u00e7\u00e3o (Insertion Sort)</p> <p>4.4 Ordena\u00e7\u00e3o usando o m\u00e9todo de ordena\u00e7\u00e3o r\u00e1pida (Quick Sort)</p> <p>4.5 Ordena\u00e7\u00e3o usando o Merge Sort</p> <p>4.6 Exerc\u00edcios ordena\u00e7\u00e3o</p>"},{"location":"ordenacao/bubble-sort/","title":"Ordena\u00e7\u00e3o usando o m\u00e9todo da bolha (Bubble Sort)","text":"<p>O m\u00e9todo de ordena\u00e7\u00e3o por bolha (Bubble Sort) \u00e9 um algoritmo simples que percorre um vetor, comparando pares de elementos adjacentes e trocando-os de posi\u00e7\u00e3o sempre que est\u00e3o fora de ordem. Esse processo se repete at\u00e9 que todos os elementos estejam organizados na ordem desejada.</p>"},{"location":"ordenacao/bubble-sort/#algoritmo","title":"Algoritmo","text":"<p>O algoritmo Bubble Sort funciona da seguinte forma:</p> <ol> <li> <p>Receba o vetor (ou lista) a ser ordenado e determine seu tamanho (n\u00famero de elementos).</p> </li> <li> <p>Crie um la\u00e7o externo que ir\u00e1 controlar o n\u00famero de passadas pelo vetor \u2014 ele ir\u00e1 do primeiro elemento at\u00e9 o pen\u00faltimo.</p> </li> <li> <p>Dentro do la\u00e7o externo, crie um la\u00e7o interno que percorre o vetor do in\u00edcio at\u00e9 o \u00faltimo elemento n\u00e3o ordenado (ou seja, do  in\u00edcio at\u00e9 <code>tamanho - i - 1</code>, onde <code>i</code> \u00e9 o \u00edndice da itera\u00e7\u00e3o externa).</p> </li> <li> <p>Compare os elementos adjacentes: se o elemento atual for maior que o pr\u00f3ximo, troque suas posi\u00e7\u00f5es.</p> </li> <li> <p>Repita esse processo at\u00e9 que todas as passadas sejam conclu\u00eddas e o vetor esteja completamente ordenado.</p> </li> </ol>"},{"location":"ordenacao/bubble-sort/#complexidade","title":"Complexidade","text":"<p>Em termos de complexidade, o Bubble Sort possui desempenho quadr\u00e1tico, ou seja, <code>O(n\u00b2)</code> no pior e no caso m\u00e9dio \u2014 o que o torna ineficiente para conjuntos de dados grandes.</p> <p>No entanto, em situa\u00e7\u00f5es onde o vetor j\u00e1 est\u00e1 ordenado, ele realiza apenas uma passada sem efetuar trocas, alcan\u00e7ando assim um desempenho de <code>O(n)</code> no melhor caso.</p> Caso Complexidade Melhor caso O(n) Caso m\u00e9dio O(n\u00b2) Pior caso O(n\u00b2) <p>Uso no dia-a-dia</p> <p>Ele \u00e9 ineficiente para conjuntos de dados grandes devido \u00e0 sua baixa efici\u00eancia em termos de tempo de execu\u00e7\u00e3o.</p>"},{"location":"ordenacao/bubble-sort/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<pre><code>public class BubbleSort\n{\n    public int[] Sort(int[] vetor)\n    {\n        int quantidadeElementos = vetor.Length;\n\n        for (int indiceAtual = 0; indiceAtual &lt; quantidadeElementos - 1; indiceAtual++)\n        {\n            for (int proximoIndice = 0; proximoIndice &lt; quantidadeElementos - indiceAtual - 1; proximoIndice++)\n            {\n                if (vetor[proximoIndice] &gt; vetor[proximoIndice + 1])\n                    Swap(vetor, proximoIndice);\n            }\n        }\n\n        return vetor;\n    }    \n\n    private void Swap(int[] vetorDesordenado, int indiceAtual)\n    {\n        int valorTemporario = vetorDesordenado[indiceAtual];\n        vetorDesordenado[indiceAtual] = vetorDesordenado[indiceAtual + 1];\n        vetorDesordenado[indiceAtual + 1] = valorTemporario;\n    }\n}\n</code></pre> Bubble Sort 1Bubble Sort 2Bubble Sort 3Bubble Sort 4Bubble Sort 5Bubble Sort 6Bubble Sort 7"},{"location":"ordenacao/exercicios-ordenacao/","title":"Exerc\u00edcios ordena\u00e7\u00e3o","text":"<p>(1) Implemente o bubble sort de forma recursiva.</p> Bubble Sort recursivo <pre><code>public class BubbleSortRecursivo\n{\n    public int[] RecursiveSort(int[] vetor, int quantidadeElementos)\n    {\n        if (quantidadeElementos == 1)\n            return vetor;\n\n        for (int indice = 0; indice &lt; quantidadeElementos - 1; indice++)\n        {\n            if (vetor[indice] &gt; vetor[indice + 1])\n                Swap(vetor, indice);\n        }\n\n        return RecursiveSort(vetor, quantidadeElementos - 1);\n    }\n\n    private void Swap(int[] vetorDesordenado, int indiceAtual)\n    {\n        int valorTemporario = vetorDesordenado[indiceAtual];\n        vetorDesordenado[indiceAtual] = vetorDesordenado[indiceAtual + 1];\n        vetorDesordenado[indiceAtual + 1] = valorTemporario;\n    }\n}\n</code></pre> <p>(2) Implemente o selection sort de forma recursiva.</p> Selection Sort recursivo <pre><code>public class SelectionSortRecursivo\n{\n    public int[] RecursiveSort(int[] vetor, int quantidadeElementos, int indice = 0)\n    {\n        if (indice &gt;= quantidadeElementos - 1)\n            return vetor;\n\n        int indiceMenorValor = indice;\n\n        for (int proximoIndice = indice + 1; proximoIndice &lt; quantidadeElementos; proximoIndice++)\n        {\n            if (vetor[proximoIndice] &lt; vetor[indiceMenorValor])\n                indiceMenorValor = proximoIndice;\n        }\n\n        if (vetor[indice] != vetor[indiceMenorValor])\n            Swap(vetor, indice, indiceMenorValor);\n\n        return RecursiveSort(vetor, quantidadeElementos, indice + 1);\n    }\n}\n</code></pre> <p>(3) Implemente o insertion sort de forma recursiva.</p> Insertion Sort recursivo <pre><code>public class InsertionSortRecursivo\n{\n    public int[] RecursiveSort(int[] vetor, int quantidadeElementos)\n    {\n        if(quantidadeElementos &lt;= 1)\n            return vetor;\n\n        RecursiveSort(vetor, quantidadeElementos - 1);\n\n        for (int indiceAtual = 1; indiceAtual &lt; quantidadeElementos; indiceAtual++)\n        {\n            int valorTemporario = vetor[indiceAtual];\n            int indiceAuxiliar = indiceAtual - 1;\n\n            while (indiceAuxiliar &gt;= 0 &amp;&amp; vetor[indiceAuxiliar] &gt; valorTemporario)\n            {\n                vetor[indiceAuxiliar + 1] = vetor[indiceAuxiliar];\n                indiceAuxiliar = indiceAuxiliar - 1;\n            }\n\n            vetor[indiceAuxiliar + 1] = valorTemporario;\n        }\n\n        return vetor;\n    }\n}\n</code></pre> <p>(4) Implemente o quick sort para ordenar um vetor de forma decrescente.</p> Quick Sort decrescente <pre><code>public class QuickSortDecrescente\n{\n    public int[] Ordenar(int[] vetor, int esquerda, int direita)\n    {\n        if (esquerda &lt; direita)\n        {\n            int pivo = Particionemento(vetor, esquerda, direita);\n            Ordenar(vetor, esquerda, pivo - 1);\n            Ordenar(vetor, pivo + 1, direita);\n        }\n\n        return vetor;\n    }\n\n    private int Particionemento(int[] vetor, int esquerda, int direita)\n    {\n        int pivo = vetor[esquerda];\n        int indicePivo = esquerda;\n\n        for (int i = esquerda + 1; i &lt;= direita; i++)\n        {\n            if (vetor[i] &gt; pivo)\n            {\n                indicePivo = indicePivo + 1;\n                Swap(vetor, i, indicePivo);\n            }\n        }\n\n        Swap(vetor, esquerda, indicePivo);\n\n        return indicePivo;\n    }\n\n    private void Swap(int[] vetorDesordenado, int esquerda, int direita)\n    {\n        int temp = vetorDesordenado[esquerda];\n        vetorDesordenado[esquerda] = vetorDesordenado[direita];\n        vetorDesordenado[direita] = temp;\n    }\n}\n</code></pre> <p>(5) Implemente o bubble sort de forma recursiva para ordenar um vetor. Deve ser poss\u00edvel escolher se a ordena\u00e7\u00e3o ser\u00e1 em forma crescente ou decrescente.</p> Bubble Sort recursivo crescente e decrescente <pre><code>public class BubbleSortRecursivoCrescenteDecrescente\n{\n    public int[] OrdenarRecursivamente(int[] vetor, int quantidadeElementos, bool ordemCrescente = true)\n    {\n        if (quantidadeElementos == 1)\n            return vetor;\n\n        for (int i = 0; i &lt; quantidadeElementos - 1; i++)\n        {\n            bool precisaTrocar;\n\n            if (ordemCrescente)                \n                precisaTrocar = vetor[i] &gt; vetor[i + 1];\n\n            else                \n                precisaTrocar = vetor[i] &lt; vetor[i + 1];  \n\n            if (precisaTrocar)\n                TrocarValores(vetor, i);\n        }\n\n        return OrdenarRecursivamente(vetor, quantidadeElementos - 1, ordemCrescente);\n    }\n\n    private void TrocarValores(int[] vetor, int indice)\n    {\n        int valorTemporario = vetor[indice];\n        vetor[indice] = vetor[indice + 1];\n        vetor[indice + 1] = valorTemporario;\n    }\n}\n</code></pre>"},{"location":"ordenacao/insertion-sort/","title":"Ordena\u00e7\u00e3o usando o m\u00e9todo de inser\u00e7\u00e3o (Insertion sort)","text":"<p>O algoritmo de ordena\u00e7\u00e3o por inser\u00e7\u00e3o (Insertion Sort) parte do princ\u00edpio de que o primeiro elemento do vetor j\u00e1 est\u00e1 em ordem. A partir do segundo, cada novo valor \u00e9 comparado com os anteriores e inserido na posi\u00e7\u00e3o correta, deslocando os elementos maiores uma posi\u00e7\u00e3o \u00e0 frente para abrir espa\u00e7o. Esse processo se repete at\u00e9 que todos os elementos estejam ordenados, formando uma sequ\u00eancia crescente a partir da esquerda. Com isso, a cada passo, o vetor vai se tornando parcialmente ordenado, at\u00e9 que esteja totalmente organizado ao final das itera\u00e7\u00f5es.</p>"},{"location":"ordenacao/insertion-sort/#algoritmo","title":"Algoritmo","text":"<p>O algoritmo de inser\u00e7\u00e3o funciona da seguinte maneira:</p> <ol> <li> <p>Inicie um la\u00e7o que percorra o vetor a partir do segundo elemento.</p> </li> <li> <p>Armazene o valor atual em uma vari\u00e1vel chamada valorTemporario.</p> </li> <li> <p>Utilize um la\u00e7o interno para comparar esse valor com os elementos anteriores.</p> </li> <li> <p>Enquanto os elementos anteriores forem maiores que valorTemporario, mova-os uma posi\u00e7\u00e3o \u00e0 frente.</p> </li> <li> <p>Continue o processo at\u00e9 encontrar um valor menor ou igual, ou at\u00e9 alcan\u00e7ar o in\u00edcio do vetor.</p> </li> <li> <p>Insira valorTemporario na posi\u00e7\u00e3o correta.</p> </li> <li> <p>Repita o processo para todos os elementos do vetor.</p> </li> </ol>"},{"location":"ordenacao/insertion-sort/#complexidade","title":"Complexidade","text":"<p>Em termos de desempenho, o Insertion Sort apresenta complexidade quadr\u00e1tica no pior e no caso m\u00e9dio, representada por <code>O(n\u00b2)</code>, pois, em cen\u00e1rios desfavor\u00e1veis, ele pode realizar um grande n\u00famero de compara\u00e7\u00f5es e deslocamentos. No entanto, se o vetor estiver quase ordenado, o algoritmo se torna bem mais eficiente, alcan\u00e7ando uma complexidade linear, <code>O(n)</code>, no melhor caso.</p> <p>Sua performance do algoritmo pode ser resumida da seguinte forma:</p> Caso Complexidade Melhor caso O(n) Caso m\u00e9dio O(n\u00b2) Pior caso O(n\u00b2) <p>Uso no dia-a-dia</p> <p>Esse algoritmo tende a ser mais eficiente que o Bubble Sort e o Selection Sort, especialmente quando aplicado a conjuntos pequenos de dados ou quase ordenados. No entanto, devido \u00e0 sua complexidade quadr\u00e1tica no pior caso, o Insertion Sort n\u00e3o \u00e9 indicado para grandes volumes de dados, j\u00e1 que seu tempo de execu\u00e7\u00e3o cresce rapidamente com o tamanho da entrada.</p>"},{"location":"ordenacao/insertion-sort/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<pre><code> public class InsertionSort\n{\n    public int[] Sort(int[] vetor)\n    {\n        int quantidadeElementos = vetor.Length;\n\n        for (int indiceAtual = 1; indiceAtual &lt; quantidadeElementos; indiceAtual++)\n        {\n            int valorTemporario = vetor[indiceAtual];\n            int indiceAuxiliar = indiceAtual - 1;\n\n            while (indiceAuxiliar &gt;= 0 &amp;&amp; vetor[indiceAuxiliar] &gt; valorTemporario)\n            {\n                vetor[indiceAuxiliar + 1] = vetor[indiceAuxiliar];\n                indiceAuxiliar = indiceAuxiliar - 1;\n            }\n\n            vetor[indiceAuxiliar + 1] = valorTemporario;\n        }\n\n        return vetor;\n    }    \n}\n</code></pre> Insertion Sort"},{"location":"ordenacao/merge-sort/","title":"Ordena\u00e7\u00e3o usando o Merge Sort","text":"<p>O algoritmo de ordena\u00e7\u00e3o Merge Sort \u00e9 mais um exemplo cl\u00e1ssico da estrat\u00e9gia de dividir para conquistar. Ele come\u00e7a dividindo o vetor original em dois subvetores, e continua dividindo cada um deles recursivamente at\u00e9 que restem apenas subvetores com um \u00fanico elemento. Em seguida, esses subvetores s\u00e3o ordenados e mesclados de forma progressiva, at\u00e9 que o vetor original seja reconstru\u00eddo \u2014 agora, totalmente ordenado.</p>"},{"location":"ordenacao/merge-sort/#algoritmo","title":"Algoritmo","text":"<p>O Merge Sort funciona da seguinte forma:</p> <ol> <li> <p>Verifique o tamanho do vetor. Se o vetor tem 0 ou 1 elemento, ele j\u00e1 est\u00e1 ordenado. Esse \u00e9 o caso base da recurs\u00e3o.</p> </li> <li> <p>Divida o vetor ao meio. Encontre o \u00edndice do meio do vetor e divida-o em dois subvetores: um da esquerda e outro da direita.</p> </li> <li> <p>Chame a fun\u00e7\u00e3o Sort para os dois subvetores. Ela ser\u00e1 chamada recursivamente para ordenar o subvetor da esquerda e o subvetor da direita.</p> </li> <li> <p>Quando os subvetores tiverem apenas 1 elemento cada, significa que o caso base da recurs\u00e3o foi atingido. Agora o algoritmo come\u00e7a a juntar os subvetores, comparando os elementos e ordenando no processo.</p> </li> <li> <p>Use a fun\u00e7\u00e3o de mesclagem (Merge). A fun\u00e7\u00e3o Merge compara os elementos dos dois subvetores (esquerda e direita), escolhendo o menor valor entre eles e colocando no vetor original. Ela repete isso at\u00e9 que todos os elementos de ambos os subvetores tenham sido inseridos de volta, agora em ordem.</p> </li> <li> <p>Continue o processo at\u00e9 o vetor original estar reconstru\u00eddo. Cada n\u00edvel da recurs\u00e3o retorna um subvetor maior e ordenado, at\u00e9 que o vetor original seja completamente reconstru\u00eddo \u2014 e dessa vez, ordenado.</p> </li> </ol>"},{"location":"ordenacao/merge-sort/#complexidade","title":"Complexidade","text":"<p>A complexidade do Merge Sort \u00e9 uma das caracter\u00edsticas que o fazem ser eficiente. A cada n\u00edvel da recurs\u00e3o em que o vetor \u00e9 dividido por 2, a complexidade \u00e9 <code>log n</code>. Em cada n\u00edvel, o algoritmo precisa percorrer todos os elementos para fazer a mesclagem, o que significa uma complexidade <code>n</code>. Juntando tudo, <code>O(n log n)</code>.</p> <p>Sua performance do algoritmo pode ser resumida da seguinte forma:</p> Caso Complexidade Melhor caso O(n log n) Caso m\u00e9dio O(n log n) Pior caso O(n\u00b2) <p>Uso no dia-a-dia</p> <p>Esse algoritmo \u00e9 amplamente utilizado em aplica\u00e7\u00f5es que possuem grandes volumes de dados em disco, por exemplo sistemas de arquivos e bancos de dados.</p>"},{"location":"ordenacao/merge-sort/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<pre><code>public class MergeSort\n{\n    public int[] Sort(int[] vetor)\n    {\n        int quantidadeElementos = vetor.Length;\n\n        // Caso base\n        // Se o vetor tiver apenas um elemento, ele j\u00e1 est\u00e1 ordenado\n        if (quantidadeElementos &lt;= 1)\n            return vetor;\n\n        int meio = quantidadeElementos / 2;\n        int[] vetorEsquerdo = new int[meio];\n        int[] vetorDireito = new int[quantidadeElementos - meio];\n\n        int indiceVetorEsquerdo = 0;\n        int indiceVetorDireito = 0;\n\n        for (; indiceVetorEsquerdo &lt; quantidadeElementos; indiceVetorEsquerdo++)\n        {\n            if (indiceVetorEsquerdo &lt; meio)\n                vetorEsquerdo[indiceVetorEsquerdo] = vetor[indiceVetorEsquerdo];\n            else\n            {\n                vetorDireito[indiceVetorDireito] = vetor[indiceVetorEsquerdo];\n                indiceVetorDireito = indiceVetorDireito + 1;\n            }\n        }\n\n        vetorEsquerdo = Sort(vetorEsquerdo);\n        vetorDireito = Sort(vetorDireito);\n        Merge(vetor, vetorEsquerdo, vetorDireito);\n\n        return vetor;\n    }\n\n    private void Merge(int[] vetor, int[] vetorEsquerdo, int[] vetorDireito)\n    {\n        int quantidadeElementosVetorEsquerdo = vetorEsquerdo.Length;\n        int quantidadeElementosVetorDireito = vetorDireito.Length;\n        int indiceVetor = 0;\n        int indiceVetorEsquerdo = 0;\n        int indiceVetorDireito = 0;\n\n        // Aqui come\u00e7a a m\u00e1gica, ou o merge\n        while (indiceVetorEsquerdo &lt; quantidadeElementosVetorEsquerdo &amp;&amp; indiceVetorDireito &lt; quantidadeElementosVetorDireito)\n        {\n            if (vetorEsquerdo[indiceVetorEsquerdo] &lt; vetorDireito[indiceVetorDireito])\n            {\n                vetor[indiceVetor] = vetorEsquerdo[indiceVetorEsquerdo];\n                indiceVetor = indiceVetor + 1;\n                indiceVetorEsquerdo = indiceVetorEsquerdo + 1;\n            }\n            else\n            {\n                vetor[indiceVetor] = vetorDireito[indiceVetorDireito];\n                indiceVetor = indiceVetor + 1;\n                indiceVetorDireito = indiceVetorDireito + 1;\n            }\n        }\n\n        while (indiceVetorEsquerdo &lt; quantidadeElementosVetorEsquerdo)\n        {\n            vetor[indiceVetor] = vetorEsquerdo[indiceVetorEsquerdo];\n            indiceVetor = indiceVetor + 1;\n            indiceVetorEsquerdo = indiceVetorEsquerdo + 1;\n        }\n\n        while (indiceVetorDireito &lt; quantidadeElementosVetorDireito)\n        {\n            vetor[indiceVetor] = vetorDireito[indiceVetorDireito];\n            indiceVetor = indiceVetor + 1;\n            indiceVetorDireito = indiceVetorDireito + 1;\n        }\n    }\n}\n</code></pre> Merge Sort 01Merge Sort 02"},{"location":"ordenacao/quick-sort/","title":"Ordena\u00e7\u00e3o usando o m\u00e9todo de ordena\u00e7\u00e3o r\u00e1pida (Quick Sort)","text":"<p>O algoritmo de ordena\u00e7\u00e3o r\u00e1pida (Quick Sort) funciona por meio de compara\u00e7\u00f5es e utiliza a estrat\u00e9gia de dividir para conquistar para ordenar os elementos. Essa estrat\u00e9gia consiste em dividir o vetor (ou lista) em subvetores menores, que s\u00e3o resolvidos de forma recursiva.</p> <p>O ponto central do algoritmo \u00e9 a escolha de um piv\u00f4, que serve como base para reorganizar os elementos: os menores que o piv\u00f4 s\u00e3o movidos para um lado, e os maiores, para o outro. Ap\u00f3s essa separa\u00e7\u00e3o, o algoritmo aplica o mesmo processo a cada subvetor, at\u00e9 que todos os elementos estejam ordenados.</p> <p>Como resultado, o Quick Sort \u00e9 um dos algoritmos de ordena\u00e7\u00e3o mais eficientes e amplamente utilizados, especialmente em grandes conjuntos de dados.</p>"},{"location":"ordenacao/quick-sort/#algoritmo","title":"Algoritmo","text":"<p>O Quick Sort funciona da seguinte forma:</p> <ol> <li> <p>Escolha um <code>piv\u00f4</code>: selecione um elemento do vetor que servir\u00e1 como refer\u00eancia para a ordena\u00e7\u00e3o.</p> </li> <li> <p>Particione o vetor: reorganize os elementos de forma que os menores que o <code>piv\u00f4</code> fiquem \u00e0 esquerda e os maiores, \u00e0 direita.</p> </li> <li> <p>Recursivamente, aplique o algoritmo: repita o processo de escolha do <code>piv\u00f4</code> e particionamento nos subvetores da esquerda e da direita.</p> </li> <li> <p>Continue dividindo: o processo se repete at\u00e9 que todos os subvetores tenham no m\u00e1ximo um elemento \u2014 o que significa que est\u00e3o ordenados.</p> </li> <li> <p>Ao final, todos os elementos estar\u00e3o na posi\u00e7\u00e3o correta, resultando em um vetor ordenado.</p> </li> </ol>"},{"location":"ordenacao/quick-sort/#complexidade","title":"Complexidade","text":"<p>A complexidade do Quick Sort varia de acordo com a escolha do <code>piv\u00f4</code> e a distribui\u00e7\u00e3o dos elementos. No melhor e no caso m\u00e9dio, sua complexidade \u00e9 <code>O(n log n)</code>, o que indica que o n\u00famero de opera\u00e7\u00f5es cresce de forma logar\u00edtimica em rela\u00e7\u00e3o ao tamanho do vetor. Isso acontece quando o piv\u00f4 consegue dividir os dados de maneira equilibrada. No entanto, no pior caso \u2014 quando o piv\u00f4 escolhido \u00e9 o menor ou o maior elemento do vetor \u2014 a divis\u00e3o fica extremamente desbalanceada, levando a uma complexidade de <code>O(n\u00b2)</code>.</p> <p>Sua performance do algoritmo pode ser resumida da seguinte forma:</p> Caso Complexidade Melhor caso O(n log n) Caso m\u00e9dio O(n log n) Pior caso O(n\u00b2) <p>Uso no dia-a-dia</p> <p>Esse algoritmo \u00e9 amplamente utilizado em aplica\u00e7\u00f5es comerciais e j\u00e1 vem implementado de forma otimizada em muitas linguagens de programa\u00e7\u00e3o modernas.</p>"},{"location":"ordenacao/quick-sort/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<pre><code> public class QuickSort\n {\n     public int[] Sort(int[] vetor, int esquerda, int direita)\n     {\n         if (esquerda &lt; direita)\n         {\n             int pivo = Particionemento(vetor, esquerda, direita);\n             Sort(vetor, esquerda, pivo - 1);\n             Sort(vetor, pivo + 1, direita);\n         }\n\n         return vetor;\n     }\n\n     private int Particionemento(int[] vetor, int esquerda, int direita)\n     {\n         int pivo = vetor[esquerda];\n         int indicePivo = esquerda;\n\n         for (int i = esquerda + 1; i &lt;= direita; i++)\n         {\n             if (vetor[i] &lt; pivo)\n             {\n                 indicePivo++;\n                 Swap(vetor, i, indicePivo);\n             }\n         }\n\n         Swap(vetor, esquerda, indicePivo);\n\n         return indicePivo;\n     }\n\n     private void Swap(int[] vetorDesordenado, int esquerda, int direita)\n     {\n         int temp = vetorDesordenado[esquerda];\n         vetorDesordenado[esquerda] = vetorDesordenado[direita];\n         vetorDesordenado[direita] = temp;\n     }\n }\n</code></pre> Quick Sort"},{"location":"ordenacao/selection-sort/","title":"Ordena\u00e7\u00e3o usando o m\u00e9todo de sele\u00e7\u00e3o (Selection Sort)","text":"<p>O algoritmo de ordena\u00e7\u00e3o por sele\u00e7\u00e3o (Selection Sort) funciona selecionando repetidamente o menor elemento da parte n\u00e3o ordenada do vetor e movendo-o para a posi\u00e7\u00e3o correta na parte ordenada.</p> <p>O processo se repete para as pr\u00f3ximas posi\u00e7\u00f5es, at\u00e9 que todo o vetor esteja ordenado. Em outras palavras, o algoritmo encontra o menor valor e o coloca na primeira posi\u00e7\u00e3o, depois encontra o segundo menor e o coloca na segunda posi\u00e7\u00e3o, e assim por diante, realizando esse procedimento <code>n - 1</code> vezes.</p>"},{"location":"ordenacao/selection-sort/#algoritmo","title":"Algoritmo","text":"<p>O algoritmo Selection Sort funciona da seguinte maneira:</p> <ol> <li> <p>Dado um vetor com n elementos, inicia-se um la\u00e7o externo que percorre os elementos do \u00edndice <code>0</code> at\u00e9 <code>n - 1</code>. Esse \u00edndice \u00e9 chamado de indiceAtual.</p> </li> <li> <p>Assumimos inicialmente que o menor valor est\u00e1 na posi\u00e7\u00e3o atual, ou seja: <code>indiceMenorValor = indiceAtual</code>.</p> </li> <li> <p>Em seguida, um la\u00e7o interno percorre os elementos \u00e0 frente (do \u00edndice <code>indiceAtual + 1</code> at\u00e9 <code>n - 1</code>) buscando o menor valor.</p> </li> <li> <p>Sempre que for encontrado um elemento menor do que o atual <code>indiceMenorValor</code>, atualizamos o <code>indiceMenorValor</code> com o \u00edndice desse novo menor valor.</p> </li> <li> <p>Ap\u00f3s o t\u00e9rmino do la\u00e7o interno, se o valor encontrado (em <code>indiceMenorValor</code>) for diferente do valor atual (em <code>indiceAtual</code>), os dois s\u00e3o trocados.</p> </li> <li> <p>O processo se repete at\u00e9 que o vetor esteja completamente ordenado ao fim do la\u00e7o externo.</p> </li> </ol>"},{"location":"ordenacao/selection-sort/#complexidade","title":"Complexidade","text":"<p>Em termos de desempenho, o Selection Sort possui complexidade quadr\u00e1tica, representada por <code>O(n\u00b2)</code>. Isso ocorre porque, independentemente da ordem inicial dos elementos, ele sempre realiza o mesmo n\u00famero de compara\u00e7\u00f5es. Assim, sua performance \u00e9 a mesma nos casos:</p> Caso Complexidade Melhor caso O(n\u00b2) Caso m\u00e9dio O(n\u00b2) Pior caso O(n\u00b2) <p>Uso no dia-a-dia</p> <p>Apesar de sua simplicidade e f\u00e1cil implementa\u00e7\u00e3o, n\u00e3o \u00e9 recomendado para grandes conjuntos de dados devido \u00e0 sua baixa efici\u00eancia em termos de tempo de execu\u00e7\u00e3o.</p>"},{"location":"ordenacao/selection-sort/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<pre><code>public class SelectionSort\n{\n    public int[] Sort(int[] vetor)\n    {\n        int indiceMenorValor;\n        int quantidadeElementos = vetor.Length;\n\n        for (int indiceAtual = 0; indiceAtual &lt; quantidadeElementos - 1; indiceAtual++)\n        {\n            indiceMenorValor = indiceAtual;\n\n            for (int proximoIndice = indiceAtual + 1; proximoIndice &lt; quantidadeElementos; proximoIndice++)\n            {\n                if (vetor[proximoIndice] &lt; vetor[indiceMenorValor])\n                    indiceMenorValor = proximoIndice;\n            }\n\n            if (vetor[indiceAtual] != vetor[indiceMenorValor])\n                Swap(vetor, indiceAtual, indiceMenorValor);\n        }\n\n        return vetor;\n    }    \n\n    private void Swap(int[] vetorDesordenado, int indiceAtual, int indiceMenorValor)\n    {\n        int valorTemporario = vetorDesordenado[indiceAtual];\n        vetorDesordenado[indiceAtual] = vetorDesordenado[indiceMenorValor];\n        vetorDesordenado[indiceMenorValor] = valorTemporario;\n    }\n}\n</code></pre> Selection Sort 1Selection Sort 2Selection Sort 3Selection Sort 4Selection Sort 5"},{"location":"pilhas/","title":"Introdu\u00e7\u00e3o \u00e0 Pilhas","text":"<p>Em busca de novos conhecimentos, Luana foi at\u00e9 a biblioteca determinada a encontrar bons livros para ler. Ao chegar, decidiu que come\u00e7aria pelos temas que considerasse mais importantes. Para cada assunto escolhido, ela se dirigia \u00e0s prateleiras, pegava o livro e o colocava cuidadosamente sobre uma mesa grande. Um a um, os livros foram sendo empilhados, formando uma pilha onde o \u00faltimo escolhido sempre ficava no topo.</p> <p>Para iniciar a leitura, Luana come\u00e7ou pelos livros que estavam no topo da pilha. Logo percebeu que aqueles que ela considerava mais importantes \u2014 e que havia colocado primeiro, no fundo da pilha \u2014 seriam os \u00faltimos a serem acessados. Para chegar at\u00e9 eles, precisaria remover todos os livros que estavam por cima, realocando-os em outros cantos da mesa. Essa situa\u00e7\u00e3o ilustra perfeitamente o funcionamento de uma estrutura de dados chamada pilha.</p> <p>Uma pilha \u00e9 uma estrutura de dados em que o \u00faltimo elemento inserido \u00e9 o primeiro a ser removido, e o primeiro inserido ser\u00e1 o \u00faltimo a sair.</p> <p>Vamos entender melhor com ela funciona.</p> <p>5.1 Pilhas e suas opera\u00e7\u00f5es</p> <p>5.2 Implementa\u00e7\u00e3o padr\u00e3o de pilhas usando C#</p> <p>5.3 Exerc\u00edcios de pilhas</p>"},{"location":"pilhas/exercicios-pilhas/","title":"Exerc\u00edcios de pilhas","text":"<p>(1) Crie um programa que copie os dados de um pilha para outra.</p> Copiando uma pilha para a outra <pre><code>public class CopiaPilha\n{\n    public Pilha PegarPilhaCopiada(Pilha pilha)\n    {\n        Pilha pilhaCopiada = new Pilha();\n        int quantidadeElementos = pilha.Tamanho();\n\n        for(int i = 0; i &lt; quantidadeElementos; i++)\n            pilhaCopiada.Push(pilha.Pop());\n\n        return pilhaCopiada;\n    }\n}\n</code></pre> <p>(2) Crie um programa para pegar o menor valor de uma pilha.</p> Pegando o menor valor da pilha <pre><code>public class MenorValorPilha\n{\n    public int PegarMenorValor(Pilha pilha)\n    {\n        int quantidadeElementos = pilha.Tamanho();\n        int menorElemento = pilha.Pop();\n\n        for(int i = 0; i &lt; quantidadeElementos - 1; i++)\n        {\n            int aux = pilha.Pop();\n            if (aux &lt; menorElemento) \n                menorElemento = aux;\n        }\n\n        return menorElemento;\n    }\n}\n</code></pre> <p>(3) Crie um programa que converta um n\u00famero inteiro em sua representa\u00e7\u00e3o bin\u00e1ria usando uma pilha. O programa deve receber um n\u00famero decimal do usu\u00e1rio e usar a pilha para armazenar os restos da divis\u00e3o sucessiva por 2, at\u00e9 que o n\u00famero seja 0. Depois, deve exibir a sequ\u00eancia de restos como o n\u00famero bin\u00e1rio correspondente.</p> Convers\u00e3o bin\u00e1ria <pre><code>public class ConversorBinario\n{\n    public string ConverterParaBinario(int numero)\n    {\n        Pilha pilha = new Pilha();\n\n        while(numero &gt; 0)\n        {\n            int resto = numero % 2;\n            pilha.Push(resto);\n            numero = numero / 2;\n        }\n\n        string numeroBinario = string.Empty;\n\n        while(!pilha.IsEmpty())\n        {\n            int bit = pilha.Pop();\n            numeroBinario = numeroBinario + bit.ToString();\n        }\n\n        return numeroBinario;\n    }\n}\n</code></pre> <p>(4) Crie um programa que inverta uma pilha usando recurs\u00e3o.</p> Usando recurs\u00e3o para inverter uma pilha <pre><code>public class PilhaInvertidaRecursiva\n{\n    public Pilha InverterPilha(Pilha pilha)\n    {\n        if(pilha.IsEmpty())\n            return pilha;\n\n        int elemento = pilha.Pop();\n\n        InverterPilha(pilha);\n\n        pilha.Push(elemento);\n\n        return pilha;\n    }\n}\n</code></pre> <p>(5) Crie um programa que ordene os elementos de uma pilha usando o algor\u00edtmo insertion sort recursivo. O algoritmo deve remover os elementos da pilha, armazen\u00e1-los e, em seguida, recoloc\u00e1-los na pilha de forma ordenada. Utilize um m\u00e9todo recursivo para inserir elementos na pilha de maneira ordenada.</p> Ordenando pilhas recursivamente <pre><code>public class OrdenacaoPilha\n{\n    public Pilha OrdenarPilha(Pilha pilha)\n    {\n        int quantidadeElementos = pilha.Tamanho();\n\n        int[] elementos = new int[quantidadeElementos];\n\n        for(int i = 0; i &lt; quantidadeElementos; i++)\n            elementos[i] = pilha.Pop();\n\n        int[] elementosOrdenados = RecursiveInsertionSort(elementos, quantidadeElementos);            \n\n        InserirRecursivo(pilha, elementosOrdenados, 0);\n\n        return pilha;\n    }\n\n    private int[] RecursiveInsertionSort(int[] vetor, int quantidadeElementos)\n    {\n        if (quantidadeElementos &lt;= 1)\n            return vetor;\n\n        RecursiveInsertionSort(vetor, quantidadeElementos - 1);\n\n        for (int indiceAtual = 1; indiceAtual &lt; quantidadeElementos; indiceAtual++)\n        {\n            int valorTemporario = vetor[indiceAtual];\n            int indiceAuxiliar = indiceAtual - 1;\n\n            while (indiceAuxiliar &gt;= 0 &amp;&amp; vetor[indiceAuxiliar] &lt; valorTemporario)\n            {\n                vetor[indiceAuxiliar + 1] = vetor[indiceAuxiliar];\n                indiceAuxiliar = indiceAuxiliar - 1;\n            }\n\n            vetor[indiceAuxiliar + 1] = valorTemporario;\n        }\n\n        return vetor;\n    }\n\n    private void InserirRecursivo(Pilha pilha, int[] elementos, int indice)\n    {\n        if (indice &gt;= elementos.Length)\n            return;\n\n        pilha.Push(elementos[indice]);\n        InserirRecursivo(pilha, elementos, indice + 1);\n    }\n}\n</code></pre>"},{"location":"pilhas/pilhas-c-sharp/","title":"Implementa\u00e7\u00e3o padr\u00e3o de pilhas usando C#","text":"<p>A linguagem C# j\u00e1 fornece uma estrutura de pilha pronta por meio da classe <code>Stack&lt;T&gt;</code>, dispon\u00edvel em <code>System.Collections.Generic</code>. As principais opera\u00e7\u00f5es s\u00e3o: <code>Push</code> para inserir elementos, <code>Pop</code> para remover o topo e <code>Peek</code> para visualizar o topo sem remov\u00ea-lo. Para verificar o tamanho da pilha ou saber se ela est\u00e1 vazia, utilizamos a propriedade <code>Count</code>.</p>"},{"location":"pilhas/pilhas-c-sharp/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<pre><code>public class PilhaPadrao\n{\n    private Stack&lt;int&gt; Itens;\n\n    public PilhaPadrao()\n        =&gt; Itens = new Stack&lt;int&gt;();\n\n    public void Push(int item) =&gt; Itens.Push(item);\n\n    public int Pop() =&gt; Itens.Pop();\n\n    public int Peek() =&gt; Itens.Peek();\n\n    public bool IsEmpty() =&gt; Itens.Count == 0;\n\n    public int Tamanho() =&gt; Itens.Count;\n}\n</code></pre> Opera\u00e7\u00f5es em uma pilha"},{"location":"pilhas/pilhas-operacoes/","title":"Pilhas e suas opera\u00e7\u00f5es","text":"<p>Pilhas s\u00e3o estruturas de dados do tipo <code>LIFO (Last In, First Out)</code>, nas quais o \u00faltimo elemento inserido \u00e9 o primeiro a ser removido. Funcionam como uma pilha de livros ou pratos, onde apenas o topo est\u00e1 acess\u00edvel. Suas principais opera\u00e7\u00f5es s\u00e3o: <code>push</code>, para inserir um novo elemento no topo; <code>pop</code>, para remover o elemento do topo; <code>peek</code> (ou <code>top</code>), para visualizar o elemento no topo sem remov\u00ea-lo; e <code>isEmpty</code>, para verificar se a pilha est\u00e1 vazia.</p>"},{"location":"pilhas/pilhas-operacoes/#insercao-de-dados-push","title":"Inser\u00e7\u00e3o de dados (push)","text":"<p>Ao inserir dados em uma pilha, se ela estiver cheia, \u00e9 necess\u00e1rio redimensionar seu tamanho para acomodar os novos elementos. Esse redimensionamento envolve a cria\u00e7\u00e3o de um novo array e a c\u00f3pia de todos os elementos existentes, resultando em uma complexidade de tempo <code>O(n)</code>. No entanto, quando h\u00e1 espa\u00e7o dispon\u00edvel, a inser\u00e7\u00e3o \u00e9 direta e ocorre em tempo constante, com complexidade <code>O(1)</code>.</p> Caso Complexidade Melhor caso O(1) Caso m\u00e9dio O(n) Pior caso O(n)"},{"location":"pilhas/pilhas-operacoes/#remocao-de-dados-pop","title":"Remo\u00e7\u00e3o de dados (pop)","text":"<p>A remo\u00e7\u00e3o de elementos em uma pilha ocorre sempre no topo, o que torna essa opera\u00e7\u00e3o simples e direta, com complexidade de tempo constante, ou seja, <code>O(1)</code>.</p> Caso Complexidade Melhor caso O(1) Caso m\u00e9dio O(1) Pior caso O(1)"},{"location":"pilhas/pilhas-operacoes/#retornando-o-elemento-do-topo-peek","title":"Retornando o elemento do topo (peek)","text":"<p>Quando pegamos o elemento do topo da pilha, n\u00e3o \u00e9 necess\u00e1rio percorr\u00ea-la, pois o elemento j\u00e1 est\u00e1 na posi\u00e7\u00e3o correta, ou seja, no topo da estrutura. Isso resulta em uma opera\u00e7\u00e3o de complexidade constante, <code>O(1)</code>.</p> Caso Complexidade Melhor caso O(1) Caso m\u00e9dio O(1) Pior caso O(1)"},{"location":"pilhas/pilhas-operacoes/#verificando-se-a-pilha-esta-vazia","title":"Verificando se a pilha est\u00e1 vazia","text":"<p>A verifica\u00e7\u00e3o de se a pilha est\u00e1 vazia \u00e9 realizada por meio de uma simples compara\u00e7\u00e3o com o elemento do topo. Portanto, a opera\u00e7\u00e3o possui complexidade <code>O(1)</code>.</p> Caso Complexidade Melhor caso O(1) Caso m\u00e9dio O(1) Pior caso O(1) <p>Uso no dia-a-dia</p> <p>A estrutura de pilha \u00e9 comumente utilizada para armazenar o hist\u00f3rico de navega\u00e7\u00e3o em navegadores, a\u00e7\u00f5es realizadas em editores de texto (como desfazer e refazer), entre outros cen\u00e1rios em que \u00e9 necess\u00e1rio manter o controle da ordem reversa das opera\u00e7\u00f5es.</p>"},{"location":"pilhas/pilhas-operacoes/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<pre><code>public class Pilha\n{\n    private int[] Itens;\n    private int Topo;\n    private const int Capacidade = 10;\n\n    public Pilha()\n    {\n        Itens = new int[Capacidade];\n        Topo = -1;\n    }\n\n    public void Push(int item)\n    {\n        if (Topo == Itens.Length - 1)\n            Redimensionar();\n\n        Topo = Topo + 1;\n        Itens[Topo] = item;\n    }\n\n    public int Pop()\n    {\n        if (IsEmpty())\n            throw new InvalidOperationException(\"A pilha est\u00e1 vazia.\");\n\n        int item = Itens[Topo];\n        Itens[Topo] = default;\n        Topo = Topo - 1;\n\n        return item;\n    }\n\n    public int Peek()\n    {\n        if (IsEmpty())\n            throw new InvalidOperationException(\"A pilha est\u00e1 vazia.\");\n\n        return Itens[Topo];\n    }\n\n    public bool IsEmpty() =&gt; Topo == -1;\n\n    public int Tamanho() =&gt; Topo + 1;\n\n    private void Redimensionar()\n    {\n        int novaCapacidade = Capacidade * 2;\n        int[] novosItens = new int[novaCapacidade];\n\n        for (int indice = 0; indice &lt; Itens.Length; indice++)\n            novosItens[indice] = Itens[indice];\n\n        Itens = novosItens;\n    }\n}\n</code></pre> Opera\u00e7\u00f5es em uma pilha"},{"location":"recursividade/","title":"Introdu\u00e7\u00e3o \u00e0 recursividade","text":"<p>Hoje \u00e9 o anivers\u00e1rio de Beatriz. Muito animada, ela decidiu comemorar com uma festa, chamando suas amigas. Sabrina, uma de suas amigas, resolveu fazer uma brincadeira com o presente que preparou especialmente para ela.</p> <p>Assim que chegou a festa, Sabrina entregou a Beatriz um presente cuidadosamente embrulhadado com papel de anivers\u00e1rio. Ao rasgar o embrulho, Beatriz encontrou uma caixa. Ao abri-la, havia outra caixa dentro. E dentro dela, mais uma. E assim por diante.</p> <p>Ap\u00f3s abrir 6 caixas, finalmente encontrou seu presente.</p> <p>Essa brincadeira \u00e9 uma met\u00e1fora perfeita para recurs\u00e3o. Assim como Beatriz foi abrindo caixas cada vez menores at\u00e9 chegar ao objetivo final, uma fun\u00e7\u00e3o recursiva se chama repetidamente, sempre com problemas menores, at\u00e9 alcan\u00e7ar o caso base \u2014 o ponto onde n\u00e3o h\u00e1 mais caixas para abrir.</p> <p>A partir da\u00ed, todo o processo come\u00e7a a se desfazer: cada chamada da fun\u00e7\u00e3o vai sendo resolvida, uma por uma, como se estiv\u00e9ssemos fechando as caixas de volta, at\u00e9 tudo estar completo.</p> <p>V\u00e1rios algoritmos importates utilizam recurs\u00e3o, tornando fundamental compreendermos como ela funciona.</p> <p>2.1 Fun\u00e7\u00f5es recursivas</p> <p>2.2 Sequ\u00eancia de Fibonacci</p> <p>2.2 Exerc\u00edcios recursividade</p>"},{"location":"recursividade/exercicios-recursividade/","title":"Exerc\u00edcios recursividade","text":"<p>(1) Crie um programa que receba um vetor de n\u00fameros inteiros e um n\u00famero a ser procurado dentro desse vetor. Implemente uma fun\u00e7\u00e3o de pesquisa recursiva que percorra o vetor e retorne o \u00edndice da primeira ocorr\u00eancia do n\u00famero procurado. Caso o n\u00famero n\u00e3o seja encontrado, a fun\u00e7\u00e3o deve retornar -1.</p> Pesquisa recursiva <pre><code>public class PesquisaSimplesRecursiva\n{\n    public int ExecutarPesquisaSimplesRecursiva(int[] vetor, int elementoProcurado, int indice)\n    {\n        if (indice &gt;= vetor.Length)\n            return -1;\n\n        if (vetor[indice] == elementoProcurado)\n            return indice;\n\n        return ExecutarPesquisaSimplesRecursiva(vetor, elementoProcurado, indice + 1);\n    }\n}\n</code></pre> <p>(2) Crie um programa que receba um vetor de n\u00fameros inteiros e um n\u00famero a ser procurado dentro desse vetor. Implemente uma fun\u00e7\u00e3o de pesquisa bin\u00e1ria recursiva que percorra o vetor e retorne o \u00edndice da primeira ocorr\u00eancia do n\u00famero procurado. Caso o n\u00famero n\u00e3o seja encontrado, a fun\u00e7\u00e3o deve retornar -1.</p> Pesquisa bin\u00e1ria recursiva <pre><code>public class PesquisaBinariaRecursiva\n{\n    public int ExecutarPesquisaBinariaRecursiva(int[] vetor, int elementoProcurado, int inicio, int fim)\n    {\n        if (inicio &gt; fim)\n            return -1;\n\n        int meio = (inicio + fim) / 2;\n\n        if (vetor[meio] == elementoProcurado)\n            return meio;\n\n        if (vetor[meio] &lt; elementoProcurado)\n            return ExecutarPesquisaBinariaRecursiva(vetor, elementoProcurado, meio + 1, fim);\n\n        return ExecutarPesquisaBinariaRecursiva(vetor, elementoProcurado, inicio, meio - 1);\n    }\n}\n</code></pre> <p>(3) Crie uma fun\u00e7\u00e3o recursiva para verificar se um n\u00famero inteiro \u00e9 primo. Um n\u00famero \u00e9 primo se ele for maior que 1 e n\u00e3o for divis\u00edvel por nenhum n\u00famero que n\u00e3o seja 1 ou ele mesmo.</p> N\u00famero primo <pre><code>public class NumeroPrimo\n{\n    public bool VerificarPrimo(int numero, int divisor)\n    {\n        if (divisor &gt;= numero)\n            return true;\n\n        if (numero % divisor == 0)\n            return false;\n\n        return VerificarPrimo(numero, divisor + 1);\n    }\n}\n</code></pre> <p>(4) Crie uma fun\u00e7\u00e3o recursiva que verifique se uma palavra \u00e9 um pal\u00edndromo, ou seja, se ela pode ser lida da mesma forma de tr\u00e1s para frente. A fun\u00e7\u00e3o deve comparar os primeiros e \u00faltimos caracteres recursivamente at\u00e9 que todos os caracteres correspondam.</p> Palidromo recursivo <pre><code>public class PalindromoRecursivo\n{\n    public bool IsPalindromo(string palavra, int inicio, int fim)\n    {\n        if (inicio &gt;= fim)\n            return true;\n\n        if (palavra[inicio] != palavra[fim])\n            return false;\n\n        return IsPalindromo(palavra, inicio + 1, fim - 1);\n    }\n}\n</code></pre> <p>(5) Crie uma fun\u00e7\u00e3o recursiva para contar quantos d\u00edgitos um n\u00famero inteiro possui. O n\u00famero deve ser passado como argumento e a fun\u00e7\u00e3o deve retornar o n\u00famero de d\u00edgitos desse n\u00famero. Utilize a recurs\u00e3o para dividir o n\u00famero sucessivamente at\u00e9 que ele se torne zero.</p> Quantidade de d\u00edgitos <pre><code>public class DigitosRecursivo\n{\n    public int PegarQuantidadeDigitos(int numero)\n    {\n        if (numero &lt; 10)\n            return 1;\n\n        return 1 + PegarQuantidadeDigitos(numero / 10);\n    }\n}\n</code></pre>"},{"location":"recursividade/fibonacci/","title":"Sequ\u00eancia de Fibonacci","text":"<p>Um dos problemas conhecidos quando se fala em recurs\u00e3o \u00e9 a sequ\u00eancia de Fibonacci. Trata-se de uma s\u00e9rie de n\u00fameros inteiros que normalmente come\u00e7a em zero e um, em que cada n\u00famero seguinte \u00e9 a soma dos dois anteriores. Essa sequ\u00eancia aparece com frequ\u00eancia em diversos fen\u00f4menos da natureza.</p> <p>Matematicamente, ela \u00e9 definida pela f\u00f3rmula <code>fn = (fn - 1) + (fn - 2)</code>. A sequ\u00eancia fica assim: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89,144, 233...</p> <p>Vamos analisar como calcular o n-\u00e9simo elemento dessa sequ\u00eancia utilizando recurs\u00e3o. Queremos o 4\u00b0 n\u00famero da sequ\u00eancia (desconsiderando o zero).</p> <pre><code>public class Fibonacci\n{\n    public int CalcularFibonacci(int numeroSequencia)\n    {\n        if (numeroSequencia &lt; 2)\n            return numeroSequencia;\n\n        return CalcularFibonacci(numeroSequencia - 1) + CalcularFibonacci(numeroSequencia - 2);\n    }\n}\n</code></pre> <p></p>"},{"location":"recursividade/funcoes-recursivas/","title":"Fun\u00e7\u00f5es recursivas","text":"<p>Fun\u00e7\u00f5es recursivas s\u00e3o aquelas que chamam a si mesmas dentro do seu pr\u00f3prio bloco de c\u00f3digo. Dessa forma, conseguem criar itera\u00e7\u00f5es at\u00e9 que o objetivo do algoritmo seja alcan\u00e7ado. A sua \u00faltima chamada \u00e9 conhecido como caso base.</p> <p>Como a fun\u00e7\u00e3o se chama a si mesma, \u00e9 necess\u00e1rio ter cuidado para n\u00e3o acabar em um loop infinito.</p> <p>Essas chamadas s\u00e3o armazenadas na mem\u00f3ria em uma estrutura chamada pilha de chamadas, ou call stack. A chamada do caso base  fica no topo dessa pilha e nenhumas das chamadas anteriores ser\u00e1 finalizada at\u00e9 que o resultado das chamadas seguintes sejam calculados.</p> <p>O c\u00f3digo abaixo calcula o fatorial de um n\u00famero. Vamos analisar como o mesmo funciona.</p> <pre><code>public class Fatorial\n{\n    public int CalcularFatorial(int numero)\n    {\n        if (numero &lt; 0)\n            return -1;\n\n        else if (numero is 0 or 1)\n            return 1;\n\n        else\n            return numero * CalcularFatorial(numero - 1);\n    }\n}\n</code></pre> <p>Se for utilizado um n\u00famero v\u00e1lido (maior ou igual a 0), podemos perceber que o caso base da fun\u00e7\u00e3o recursiva retorna 1. Se utilizarmos o n\u00famero 3, a fun\u00e7\u00e3o se chamar\u00e1 algumas vezes, decrementando o valor em 1 a cada chamada, at\u00e9 que a condi\u00e7\u00e3o do <code>else if</code> seja satisfeita. A partir da\u00ed, os calculos come\u00e7ar\u00e3o a ser feitos na ordem inversa, conforme as chamadas anteriores forem sendo resolvidas.</p> <p></p>"},{"location":"vetores/","title":"Introdu\u00e7\u00e3o \u00e0 vetores","text":"<p>Ap\u00f3s dias de trabalho duro, Let\u00edcia decidiu que estava na hora de tirar f\u00e9rias. Comprou sua passagem a\u00e9rea para o destino desejado e foi ao aeroporto dirigindo seu carro.</p> <p>Ao chegar, ela precisou deixa-lo no estacionamento. No retorno, para encontrar seu carro, Let\u00edcia n\u00e3o precisar\u00e1 procurar em cada vaga, basta lembrar o n\u00famero da vaga onde estacionou.</p> <p>Um estacionamento funciona igual um vetor (array). Cada vaga tem um n\u00famero fixo (seu \u00edndice). Pode ter algo l\u00e1 ou n\u00e3o (valor armazenado naquele \u00edndice). Para que ela encontre seu carro, basta olhar o n\u00famero da vaga (acesso ao que est\u00e1 armazenado).</p> <p>Mas h\u00e1 um problema: se todas as vagas estiverem ocupadas, Let\u00edcia n\u00e3o conseguir\u00e1 estacionar. Vetores possuem tamanhos fixos e n\u00e3o podem crescer sem realoca\u00e7\u00e3o.</p> <p>Vamos entender como podemos usar vetores (arrays).</p> <p>1.1 Formas de uso</p> <p>1.2 Pesquisa simples</p> <p>1.3 Pesquisa bin\u00e1ria</p> <p>1.4 Exerc\u00edcios</p>"},{"location":"vetores/exercicios-vetores/","title":"Exerc\u00edcios","text":"<p>(1) Crie um programa que receba palavras e verifique se elas s\u00e3o pal\u00edndromos.</p> Verificando pal\u00edndromos <pre><code>public class Palindromos\n{\n    public bool IsPalindromo(string palavra)\n    {\n        int inicio = 0;\n        int fim = palavra.Length - 1;\n\n        while (inicio &lt; fim)\n        {\n            if (palavra[inicio] != palavra[fim])\n                return false;\n\n            inicio = inicio + 1;\n            fim = fim - 1;\n        }\n\n        return true;\n    }\n}\n</code></pre> <p>(2) Crie um programa que receba uma frase e uma palavra. Verifique se essa palavra est\u00e1 na frase recebida.</p> Procurando palavras <pre><code>public class ProcuraPalavras\n{\n    public bool PalavraEstaNoTexto(string texto, string palavra)\n    {\n        int indiceTexto = 0;\n        int indicePalavra = 0;\n        int quantidadeCaracteres = palavra.Length;\n\n        while(indiceTexto &lt;= texto.Length - 1 &amp;&amp; indicePalavra &lt;= quantidadeCaracteres - 1)\n        {\n            if (palavra[indicePalavra] == texto[indiceTexto])\n            {\n                if (indicePalavra == quantidadeCaracteres - 1)\n                    return true;\n\n                else if (indicePalavra &lt; quantidadeCaracteres - 1)\n                    indicePalavra = indicePalavra + 1;\n\n                else\n                {\n                    if (indicePalavra &gt; 0)\n                        indicePalavra = 0;\n                }\n            }\n\n            indiceTexto = indiceTexto + 1;\n        }\n\n        return false;\n    }\n}\n</code></pre> <p>(3) Crie um programa que leia 10 n\u00fameros inteiros e armazene-os em um vetor. Ap\u00f3s isso, inverta a ordem dos elementos do vetor e exiba o vetor invertido.</p> Invertendo vetores <pre><code>public class InverteVetor\n{\n    public int[] Inverter(int[] vetor)\n    {\n        int[] vetorInvertido = new int[vetor.Length];\n        int indiceVetorInvertido = 0;\n\n        for (int indice = vetor.Length - 1; indice &gt;= 0; indice--)\n        {\n            vetorInvertido[indiceVetorInvertido] = vetor[indice];\n            indiceVetorInvertido = indiceVetorInvertido + 1;\n        }\n\n        return vetorInvertido;\n    }\n}\n</code></pre> <p>(4) Crie um programa que leia 10 n\u00fameros inteiros e os armazene em um vetor. Em seguida, encontre e exiba o maior e o menor n\u00famero do vetor.</p> Maior e menor valores <pre><code>public class MaiorMenorNumero\n{\n    public string PegarMaiorMenor(int[] vetor)\n    {\n        int maior = vetor[0];\n        int menor = vetor[0];\n\n        for (int indice = 0; indice &lt; vetor.Length; indice++)\n        {\n            if (vetor[indice] &gt; maior)\n                maior = vetor[indice];\n            else if (vetor[indice] &lt; menor)\n                menor = vetor[indice];\n        }\n\n        return $\"{maior} {menor}\";\n    }\n</code></pre> <p>(5) Crie um programa que leia 10 n\u00fameros inteiros e os armazene em um vetor. O programa deve ent\u00e3o contar quantos n\u00fameros s\u00e3o pares e quantos s\u00e3o \u00edmpares no vetor e exibir essa informa\u00e7\u00e3o.</p> Descobrindo pares e impares <pre><code>public class ParesImpares\n{\n    public string ContarParesImpares(int[] vetor)\n    {\n        int pares = 0;\n        int impares = 0;\n\n        for (int indice = 0; indice &lt; vetor.Length; indice++)\n        {\n            if (vetor[indice] % 2 == 0)\n                pares = pares + 1;\n            else\n                impares = impares + 1;\n        }\n\n        return $\"{pares} {impares}\";\n    }\n}\n</code></pre>"},{"location":"vetores/pesquisa_binaria/","title":"Pesquisa bin\u00e1ria","text":"<p>A pesquisa bin\u00e1ria \u00e9 um algoritmo de pesquisa baseado na estrat\u00e9gia de dividir e conquistar. Ele \u00e9 aplicado a vetores e listas ordenadas, reduzindo pela metade a \u00e1rea de pesquisa a cada itera\u00e7\u00e3o at\u00e9 encontrar o elemento desejado. </p> <p>Sua efici\u00eancia se destaca em rela\u00e7\u00e3o \u00e0 pesquisa linear, pois evita a necessidade de examinar todos os elementos do vetor, tornando a pesquisa significativamente mais r\u00e1pida.</p>"},{"location":"vetores/pesquisa_binaria/#algoritmo","title":"Algoritmo","text":"<p>O algoritmo da pesquisa bin\u00e1ria segue os seguintes passos:</p> <ol> <li> <p>Crie uma itera\u00e7\u00e3o (loop) que execute enquanto o \u00edndice inicial <code>I</code> seja menor ou igual ao indice final <code>F</code></p> </li> <li> <p>Calcule o \u00edndice do meio (K) do vetor: <code>(I + F) / 2</code>.</p> </li> <li> <p>Compare o valor do elemento no \u00edndice K com o elemento procurado:     3.1. Se o valor em K for menor que o procurado, atualize o \u00edndice inicial para <code>K + 1</code>.     3.2 Se o valor em K for maior que o procurado, atualize o \u00edndice final para <code>K - 1</code>.     3.3 Se o valor em K for igual ao procurado, retorne <code>K</code>.  </p> </li> <li> <p>Repita os passos 2 e 3 at\u00e9 encontrar o elemento ou at\u00e9 que o \u00edndice inicial seja maior que o \u00edndice final.  </p> </li> <li> <p>Se o valor n\u00e3o estiver no vetor, retorne <code>-1</code>.  </p> </li> </ol>"},{"location":"vetores/pesquisa_binaria/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<pre><code>public class PesquisaBinaria\n{\n    public int ExecutarPesquisaBinaria(int[] vetor, int elementoProcurado)\n    {\n        int inicio = 0;\n        int fim = vetor.Length - 1;\n        int meio = 0;\n\n        while (inicio &lt;= fim)\n        {\n            meio = (inicio + fim) / 2;\n\n            if (vetor[meio] == elementoProcurado)\n                return meio;\n\n            else if (vetor[meio] &lt; elementoProcurado)\n                inicio = meio + 1;\n            else\n                fim = meio - 1;\n        }\n\n        return -1;\n    }    \n}\n</code></pre> Itera\u00e7\u00e3o 1Itera\u00e7\u00e3o 2"},{"location":"vetores/pesquisa_simples/","title":"Pesquisa simples (sequencial)","text":"<p>Quando for necess\u00e1rio procurar dados em um vetor, \u00e9 poss\u00edvel fazer uma pesquisa sequencial. Esse m\u00e9todo percorre o vetor elemento por elemento, verificando se o valor atual corresponde ao valor procurado. Se houver uma correspond\u00eancia, o \u00edndice do elemento \u00e9 retornado imediatamente.</p>"},{"location":"vetores/pesquisa_simples/#algoritmo","title":"Algoritmo","text":"<p>O algoritmo da pesquisa simples segue os seguintes passos:</p> <ol> <li> <p>Determine o tamanho do vetor <code>T</code>.</p> </li> <li> <p>Percorra o vetor do \u00edndice inicial <code>I</code> at\u00e9 <code>T - 1</code>.</p> </li> <li> <p>Se o elemento no \u00edndice atual for igual ao valor procurado, retorne esse \u00edndice.</p> </li> <li> <p>Se o elemento n\u00e3o for encontrado, retorne <code>-1</code>.</p> </li> </ol>"},{"location":"vetores/pesquisa_simples/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<pre><code> public class PesquisaSimples\n{\n    public int ExecutarPesquisaSimples(int[] vetor, int elementoProcurado)\n    {\n        for (int indice = 0; indice &lt; vetor.Length - 1; indice = indice + 1)\n        {\n            if (vetor[indice] == elementoProcurado)\n                return indice;\n        }\n\n        return -1;\n    }    \n}\n</code></pre> Itera\u00e7\u00e3o 1Itera\u00e7\u00e3o 2Itera\u00e7\u00e3o 3"},{"location":"vetores/uso-basico/","title":"Uso b\u00e1sico de vetores (Array)","text":"<p>Vetores s\u00e3o estruturas de dados que armazenam uma sequ\u00eancia de elementos, todos do mesmo tipo. Esses elementos podem ser n\u00fameros, strings, objetos, ou at\u00e9 mesmo outros vetores.</p> <p>Em programa\u00e7\u00e3o, os vetores s\u00e3o frequentemente chamados de arrays (ou listas, dependendo da linguagem). Eles s\u00e3o uma forma eficaz de organizar dados para facilitar o acesso, manipula\u00e7\u00e3o e processamento.</p> <p></p> <pre><code>int[] vetor = { 3, 1, 2, 7, 10, 4, 8, 6, 12, 15 }; \n</code></pre>"},{"location":"vetores/uso-basico/#operacoes-em-vetores","title":"Opera\u00e7\u00f5es em vetores","text":"<p>Para manipular vetores, precisamos acessar seus \u00edndices. Vamos ver como isso funciona na pr\u00e1tica.</p>"},{"location":"vetores/uso-basico/#acessando-seus-elementos","title":"Acessando seus elementos","text":"<p>Para acessar valores em um vetor, utilizamos seus \u00edndices, que variam de <code>0</code> at\u00e9 <code>n - 1</code> (onde n \u00e9 o tamanho do vetor). Se tentarmos acessar a posi\u00e7\u00e3o 20, por exemplo, ocorrer\u00e1 a exce\u00e7\u00e3o IndexOutOfRangeException.</p> <pre><code> int[] vetor = { 3, 1, 2, 7, 10, 4, 8, 6, 12, 15 }; \n\n Console.WriteLine(vetor[5]); // 4     \n\n Console.WriteLine(vetor[20]); // Index out of range \n</code></pre> <p>Adi\u00e7\u00e3o de elementos</p> <p>N\u00e3o \u00e9 poss\u00edvel adicionar elementos em um vetor de tamanho fixo. Seria necess\u00e1rio criar outro vetor, copiar os elementos do primeiro para o segundo e ent\u00e3o adicionar os novos elementos.</p>"},{"location":"vetores/uso-basico/#adicao-de-elementos","title":"Adi\u00e7\u00e3o de elementos","text":"<p>Para adicionar elementos, criaremos um novo vetor. O tamanho desse novo vetor ser\u00e1 igual ao tamanho do vetor original somado \u00e0 quantidade de novos elementos.</p> <pre><code>int[] vetorAnterior = { 3, 1, 2, 7, 10, 4, 8, 6, 12, 15 };  \nint novoElemento = 29;\n\nint[] vetorNovo = new int[vetorAnterior.Length + 1];\n</code></pre> <p>Ap\u00f3s criar o novo vetor com o tamanho expandido, basta inserir os elementos nele e, em seguida, atualizar o vetor original.</p> <pre><code>Array.Copy(vetorAnterior, vetorNovo, vetorAnterior.Length);\n\nvetorNovo[vetorNovo.Length - 1] = novoElemento;\n\nvetorAnterior = vetorNovo;\n</code></pre> <p>Cuidado com o \u00edndice</p> <p>Cuidado para n\u00e3o acessar uma posi\u00e7\u00e3o al\u00e9m do tamanho do vetor. Isso resultar\u00e1 na exce\u00e7\u00e3o IndexOufOfRange.</p>"}]}